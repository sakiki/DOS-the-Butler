
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Traits - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.gif" width="270" height="53" style="border-style:none" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>
	<br>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Traits" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/d/download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:44:04 2008
</div>
</div>

<!-- Generated by Ddoc from traits.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D &rarr;</a></li>
	<li><a href="lex.html" title="D Language Specification">Language &rarr;</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos &rarr;</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons &rarr;</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D 1.0 &rarr;</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>
	<li><a href="module.html">Modules</a></li>
	<li><a href="declaration.html">Declarations</a></li>
	<li><a href="type.html">Types</a></li>
	<li><a href="property.html">Properties</a></li>
	<li><a href="attribute.html">Attributes</a></li>
	<li><a href="pragma.html">Pragmas</a></li>
	<li><a href="expression.html">Expressions</a></li>
	<li><a href="statement.html">Statements</a></li>
	<li><a href="arrays.html">Arrays</a></li>
	<li><a href="struct.html">Structs &amp; Unions</a></li>
	<li><a href="class.html">Classes</a></li>
	<li><a href="interface.html">Interfaces</a></li>
	<li><a href="enum.html">Enums</a></li>
	<li><a href="const3.html">Const and Invariant</a></li>
	<li><a href="function.html">Functions</a></li>
	<li><a href="operatoroverloading.html">Operator Overloading</a></li>
	<li><a href="template.html">Templates</a></li>
	<li><a href="template-mixin.html">Template Mixins</a></li>
	<li><a href="dbc.html">Contracts</a></li>
	<li><a href="version.html">Conditional Compilation</a></li>
	<li><a href="traits.html">Traits</a></li>
	<li><a href="errors.html">Handling errors</a></li>
	<li><a href="garbage.html">Garbage Collection</a></li>
	<li><a href="float.html">Floating Point</a></li>
	<li><a href="iasm.html">Inline Assembler</a></li>
	<li><a href="ddoc.html">Documentation Comments</a></li>
	<li><a href="interfaceToC.html">Interfacing To C</a></li>
	<li><a href="cpp_interface.html">Interfacing To C++</a></li>
	<li><a href="portability.html">Portability Guide</a></li>
	<li><a href="html.html">Embedding D in HTML</a></li>
	<li><a href="entity.html">Named Character Entities</a></li>
	<li><a href="abi.html">Application Binary Interface</a></li>
    </ul>
    </div>
    
<form action="http://www.google.com/translate" onsubmit="this.u.value=window.location.href" method="GET">
<input value="en" name="hl" type="hidden"/>
<input value="UTF8" name="ie" type="hidden"/>
<input value="" name="u" type="hidden"/>
<select name="langpair">
<option value="en|de"/>German
<option value="en|fr"/>French
<option value="en|it"/>Italian
<option value="en|pt"/>Portuguese
<option value="en|es"/>Spanish
<option value="en|ar"/>Arabic
<option value="en|zh-CN"/>Chinese (Simplified)
<option value="en|ja"/>Japanese
<option value="en|ko"/>Korean
<option value="en|ru"/>Russian
</select><br/>
<input value="Translate" type="submit"/>
</form>


    
<br><br>
<br><br>
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/* 180x150, created 2/18/08 */
/**/google_ad_slot = "4228873179";
/**/google_ad_width = 180;
/**/google_ad_height = 150;
/**/google_cpa_choice = ""; // on file
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>



</div>
<div id="content">
  <h1>     Traits</h1>
  
	<p>Traits are extensions to the language to enable
	programs, at compile time, to get at information
	internal to the compiler. This is also known as
	compile time reflection.
	It is done as a special, easily extended syntax (similar
	to Pragmas) so that new capabilities can be added
	as required.
	</p>

<pre class="bnf"><i>TraitsExpression</i>:
    <b>__traits</b> <b>(</b> <i>TraitsKeyword</i> <b>,</b> <i>TraitsArguments</i> <b>)</b>

<i>TraitsKeyword</i>:
    <b>isAbstractClass</b>
    <b>isArithmetic</b>
    <b>isAssociativeArray</b>
    <b>isFinalClass</b>
    <b>isFloating</b>
    <b>isIntegral</b>
    <b>isScalar</b>
    <b>isStaticArray</b>
    <b>isUnsigned</b>
    <b>isVirtualFunction</b>
    <b>isAbstractFunction</b>
    <b>isFinalFunction</b>
    <b>hasMember</b>
    <b>getMember</b>
    <b>getVirtualFunctions</b>
    <b>classInstanceSize</b>
    <b>allMembers</b>
    <b>derivedMembers</b>
    <b>isSame</b>
    <b>compiles</b>

<i>TraitsArguments</i>:
    <i>TraitsArgument</i>
    <i>TraitsArgument</i> <b>,</b> <i>TraitsArguments</i>

<i>TraitsArgument</i>:
    <i>AssignExpression</i>
    <i>Type</i>
</pre>

<h2>isArithmetic</h2>


	<p>If the arguments are all either types that are arithmetic types,
	or expressions that are typed as arithmetic types, then <b>true</b>
	is returned.
	Otherwise, <b>false</b> is returned.
	If there are no arguments, <b>false</b> is returned.</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> i;
    writefln(<span class="d_keyword">__traits</span>(isArithmetic, <span class="d_keyword">int</span>));
    writefln(<span class="d_keyword">__traits</span>(isArithmetic, i, i+1, <span class="d_keyword">int</span>));
    writefln(<span class="d_keyword">__traits</span>(isArithmetic));
    writefln(<span class="d_keyword">__traits</span>(isArithmetic, <span class="d_keyword">int</span>*));
}
</pre>

	<p>Prints:</p>

<pre class="console">true
true
false
false
</pre>

<h2>isFloating</h2>


	<p>Works like <b>isArithmetic</b>, except it's for floating
	point types (including imaginary and complex types).</p>

<h2>isIntegral</h2>


	<p>Works like <b>isArithmetic</b>, except it's for integral
	types (including character types).</p>

<h2>isScalar</h2>


	<p>Works like <b>isArithmetic</b>, except it's for scalar
	types.</p>

<h2>isUnsigned</h2>


	<p>Works like <b>isArithmetic</b>, except it's for unsigned
	types.</p>

<h2>isStaticArray</h2>


	<p>Works like <b>isArithmetic</b>, except it's for static array
	types.</p>

<h2>isAssociativeArray</h2>


	<p>Works like <b>isArithmetic</b>, except it's for associative array
	types.</p>

<h2>isAbstractClass</h2>


	<p>If the arguments are all either types that are abstract classes,
	or expressions that are typed as abstract classes, then <b>true</b>
	is returned.
	Otherwise, <b>false</b> is returned.
	If there are no arguments, <b>false</b> is returned.</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> C { <span class="d_keyword">int</span> foo(); }

<span class="d_keyword">void</span> main()
{
    C c;
    writefln(<span class="d_keyword">__traits</span>(isAbstractClass, C));
    writefln(<span class="d_keyword">__traits</span>(isAbstractClass, c, C));
    writefln(<span class="d_keyword">__traits</span>(isAbstractClass));
    writefln(<span class="d_keyword">__traits</span>(isAbstractClass, <span class="d_keyword">int</span>*));
}
</pre>

	<p>Prints:</p>

<pre class="console">true
true
false
false
</pre>

<h2>isFinalClass</h2>


	<p>Works like <b>isAbstractClass</b>, except it's for final
	classes.</p>

<h2>isVirtualFunction</h2>


	<p>Takes one argument. If that argument is a virtual function,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C
{
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_keyword">__traits</span>(isVirtualFunction, C.bar));  <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(isVirtualFunction, S.bar));  <span class="d_comment">// false
</span>}
</pre>

<h2>isAbstractFunction</h2>


	<p>Takes one argument. If that argument is an abstract function,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C
{
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> AC
{
  <span class="d_keyword">abstract</span> <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_keyword">__traits</span>(isAbstractFunction, C.bar));   <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(isAbstractFunction, S.bar));   <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(isAbstractFunction, AC.foo));  <span class="d_comment">// true
</span>}
</pre>

<h2>isFinalFunction</h2>


	<p>Takes one argument. If that argument is a final function,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C
{
  <span class="d_keyword">void</span> bar() { }
  <span class="d_keyword">final</span> <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC
{
  <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_keyword">__traits</span>(isFinalFunction, C.bar));	  <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(isFinalFunction, S.bar));	  <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(isFinalFunction, C.foo));	  <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(isFinalFunction, FC.foo));  <span class="d_comment">// true
</span>}
</pre>

<h2>hasMember</h2>


	<p>The first argument is a type that has members, or
	is an expression of a type that has members.
	The second argument is a string.
	If the string is a valid property of the type,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> m;
}

<span class="d_keyword">void</span> main()
{   S s;

    writefln(<span class="d_keyword">__traits</span>(hasMember, S, <span class="d_string">"m"</span>)); <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(hasMember, s, <span class="d_string">"m"</span>)); <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(hasMember, S, <span class="d_string">"y"</span>)); <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(hasMember, <span class="d_keyword">int</span>, <span class="d_string">"sizeof"</span>)); <span class="d_comment">// true
</span>}
</pre>

<h2>getMember</h2>


	<p>Takes two arguments, the second must be a string.
	The result is an expression formed from the first
	argument, followed by a '.', followed by the second
	argument as an identifier.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> mx;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> my;
}

<span class="d_keyword">void</span> main()
{ S s;

  <span class="d_keyword">__traits</span>(getMember, s, <span class="d_string">"mx"</span>) = 1;  <span class="d_comment">// same as s.mx=1;
</span>  writefln(<span class="d_keyword">__traits</span>(getMember, s, <span class="d_string">"m"</span> ~ <span class="d_string">"x"</span>)); <span class="d_comment">// 1
</span>
  <span class="d_keyword">__traits</span>(getMember, S, <span class="d_string">"mx"</span>) = 1;  <span class="d_comment">// error, no this for S.mx
</span>  <span class="d_keyword">__traits</span>(getMember, S, <span class="d_string">"my"</span>) = 2;  <span class="d_comment">// ok
</span>}
</pre>

<h2>getVirtualFunctions</h2>


	<p>The first argument is a class type or an expression of
	class type.
	The second argument is a string that matches the name of
	one of the functions of that class.
	The result is an array of the virtual overloads of that function.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">this</span>() { }
    ~<span class="d_keyword">this</span>() { }
    <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 2; }
}

<span class="d_keyword">void</span> main()
{
    D d = <span class="d_keyword">new</span> D();

    <span class="d_keyword">foreach</span> (t; <span class="d_keyword">__traits</span>(getVirtualFunctions, D, <span class="d_string">"foo"</span>))
	writefln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(t)));

    <span class="d_keyword">alias</span> <span class="d_keyword">typeof</span>(<span class="d_keyword">__traits</span>(getVirtualFunctions, D, <span class="d_string">"foo"</span>)) b;
    <span class="d_keyword">foreach</span> (t; b)
	writefln(<span class="d_keyword">typeid</span>(t));

    <span class="d_keyword">auto</span> i = <span class="d_keyword">__traits</span>(getVirtualFunctions, d, <span class="d_string">"foo"</span>)[1](1);
    writefln(i);
}
</pre>

	<p>Prints:</p>

<pre class="console">void()
int()
void()
int()
2
</pre>

<h2>classInstanceSize</h2>


	<p>Takes a single argument, which must evaluate to either
	a class type or an expression of class type.
	The result
	is of type <tt>size_t</tt>, and the value is the number of
	bytes in the runtime instance of the class type.
	It is based on the static type of a class, not the
	polymorphic type.
	</p>

<h2>allMembers</h2>


	<p>Takes a single argument, which must evaluate to either
	a type or an expression of type.
	An array of string literals is returned, each of which
	is the name of a member of that type combined with all
	of the members of the base classes (if the class is a type).
	No name is repeated.
	Builtin properties are not included.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">this</span>() { }
    ~<span class="d_keyword">this</span>() { }
    <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> a = <span class="d_keyword">__traits</span>(allMembers, D);
    writefln(a);
    <span class="d_comment">// [_ctor,_dtor,foo,print,toString,toHash,opCmp,opEquals]
</span>}
</pre>

	<p>The order in which the strings appear in the result
	is not defined.</p>

<h2>derivedMembers</h2>


	<p>Takes a single argument, which must evaluate to either
	a type or an expression of type.
	An array of string literals is returned, each of which
	is the name of a member of that type.
	No name is repeated.
	Base class member names are not included.
	Builtin properties are not included.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">this</span>() { }
    ~<span class="d_keyword">this</span>() { }
    <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> a = <span class="d_keyword">__traits</span>(derivedMembers, D);
    writefln(a);	<span class="d_comment">// [_ctor,_dtor,foo]
</span>}
</pre>

	<p>The order in which the strings appear in the result
	is not defined.</p>

<h2>isSame</h2>


	<p>Takes two arguments and returns bool <b>true</b> if they
	are the same symbol, <b>false</b> if not.</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S { }

<span class="d_keyword">int</span> foo();
<span class="d_keyword">int</span> bar();

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_keyword">__traits</span>(isSame, foo, foo)); <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(isSame, foo, bar)); <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(isSame, foo, S));   <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(isSame, S, S));     <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(isSame, std, S));   <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(isSame, std, std)); <span class="d_comment">// true
</span>}
</pre>

	<p>If the two arguments are expressions made up of literals
	or enums that evaluate to the same value, true is returned.</p>

<h2>compiles</h2>


	<p>Returns a bool <b>true</b> if all of the arguments
	compile (are semantically correct).
	The arguments can be symbols, types, or expressions that
	are syntactically correct.
	The arguments cannot be statements or declarations.
	</p>

	<p>If there are no arguments, the result is <b>false</b>.</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> s1;
    <span class="d_keyword">int</span> s2;
}

<span class="d_keyword">int</span> foo();
<span class="d_keyword">int</span> bar();

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_keyword">__traits</span>(compiles));                      <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, foo));                 <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, foo + 1));             <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, &amp;foo + 1));            <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, <span class="d_keyword">typeof</span>(1)));           <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, S.s1));                <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, S.s3));                <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, 1,2,3,<span class="d_keyword">int</span>,<span class="d_keyword">long</span>,std));  <span class="d_comment">// true
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, 3[1]));                <span class="d_comment">// false
</span>    writefln(<span class="d_keyword">__traits</span>(compiles, 1,2,3,<span class="d_keyword">int</span>,<span class="d_keyword">long</span>,3[1])); <span class="d_comment">// false
</span>}
</pre>

	<p>This is useful for:</p>

	<ul>	<li>Giving better error messages inside generic code than
	the sometimes hard to follow compiler ones.</li>
	<li>Doing a finer grained specialization than template
	partial specialization allows for.</li>
	</ul>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>




<div id="copyright">

Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Traits" title="Read/write comments and feedback">Comments</a>
</div>

</body>
</html>

