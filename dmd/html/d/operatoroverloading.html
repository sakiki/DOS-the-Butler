
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Operator Overloading - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.gif" width="270" height="53" style="border-style:none" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>
	<br>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/OperatorOverloading
" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/d/download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:44:01 2008
</div>
</div>

<!-- Generated by Ddoc from operatoroverloading.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D &rarr;</a></li>
	<li><a href="lex.html" title="D Language Specification">Language &rarr;</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos &rarr;</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons &rarr;</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D 1.0 &rarr;</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>
	<li><a href="module.html">Modules</a></li>
	<li><a href="declaration.html">Declarations</a></li>
	<li><a href="type.html">Types</a></li>
	<li><a href="property.html">Properties</a></li>
	<li><a href="attribute.html">Attributes</a></li>
	<li><a href="pragma.html">Pragmas</a></li>
	<li><a href="expression.html">Expressions</a></li>
	<li><a href="statement.html">Statements</a></li>
	<li><a href="arrays.html">Arrays</a></li>
	<li><a href="struct.html">Structs &amp; Unions</a></li>
	<li><a href="class.html">Classes</a></li>
	<li><a href="interface.html">Interfaces</a></li>
	<li><a href="enum.html">Enums</a></li>
	<li><a href="const3.html">Const and Invariant</a></li>
	<li><a href="function.html">Functions</a></li>
	<li><a href="operatoroverloading.html">Operator Overloading</a></li>
	<li><a href="template.html">Templates</a></li>
	<li><a href="template-mixin.html">Template Mixins</a></li>
	<li><a href="dbc.html">Contracts</a></li>
	<li><a href="version.html">Conditional Compilation</a></li>
	<li><a href="traits.html">Traits</a></li>
	<li><a href="errors.html">Handling errors</a></li>
	<li><a href="garbage.html">Garbage Collection</a></li>
	<li><a href="float.html">Floating Point</a></li>
	<li><a href="iasm.html">Inline Assembler</a></li>
	<li><a href="ddoc.html">Documentation Comments</a></li>
	<li><a href="interfaceToC.html">Interfacing To C</a></li>
	<li><a href="cpp_interface.html">Interfacing To C++</a></li>
	<li><a href="portability.html">Portability Guide</a></li>
	<li><a href="html.html">Embedding D in HTML</a></li>
	<li><a href="entity.html">Named Character Entities</a></li>
	<li><a href="abi.html">Application Binary Interface</a></li>
    </ul>
    </div>
    
<form action="http://www.google.com/translate" onsubmit="this.u.value=window.location.href" method="GET">
<input value="en" name="hl" type="hidden"/>
<input value="UTF8" name="ie" type="hidden"/>
<input value="" name="u" type="hidden"/>
<select name="langpair">
<option value="en|de"/>German
<option value="en|fr"/>French
<option value="en|it"/>Italian
<option value="en|pt"/>Portuguese
<option value="en|es"/>Spanish
<option value="en|ar"/>Arabic
<option value="en|zh-CN"/>Chinese (Simplified)
<option value="en|ja"/>Japanese
<option value="en|ko"/>Korean
<option value="en|ru"/>Russian
</select><br/>
<input value="Translate" type="submit"/>
</form>


    
<br><br>
<br><br>
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/* 180x150, created 2/18/08 */
/**/google_ad_slot = "4228873179";
/**/google_ad_width = 180;
/**/google_ad_height = 150;
/**/google_cpa_choice = ""; // on file
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>



</div>
<div id="content">
  <h1>     Operator Overloading</h1>
  
	<p>Overloading is accomplished by interpreting specially named
	struct and class member functions as being implementations of unary and
	binary operators. No additional syntax is used.
	</p>

<h2>Unary Operator Overloading</h2>


	<table border=1 cellpadding=4 cellspacing=0>	<caption>Overloadable Unary Operators</caption>

	<tr><th><i>op</i></th> <th><i>opfunc</i></th> </tr>

	<tr>	<td>-<i>e</i></td>
	<td><tt>opNeg</tt></td>
	</tr>

	<tr>	<td>+<i>e</i></td>
	<td><tt>opPos</tt></td>
	</tr>

	<tr>	<td>~<i>e</i></td>
	<td><tt>opCom</tt></td>
	</tr>

	<tr>	<td>*<i>e</i></td>
	<td><tt>opStar</tt></td>
	</tr>


	<tr>	<td><i>e</i>++</td>
	<td><tt>opPostInc</tt></td>
	</tr>

	<tr>	<td><i>e</i>--</td>
	<td><tt>opPostDec</tt></td>
	</tr>

	<tr>	<td>cast(<i>type</i>)<i>e</i></td>
	<td><tt>opCast</tt></td>
	</tr>

	</table>


	<p>Given a unary
	overloadable operator <i>op</i> and its corresponding
	class or struct member
	function name <i>opfunc</i>, the syntax:
	</p>

<pre class="d_code"><i>op</i> a
</pre>

	<p>where <i>a</i> is a class or struct object reference,
	is interpreted as if it was written as:
	</p>
<pre class="d_code">a.<i>opfunc</i>()
</pre>

<h3>Overloading ++<i>e</i> and --<i>e</i></h3>

	<p>Since ++<i>e</i> is defined to be semantically equivalent
	to (<i>e</i> += 1), the expression ++<i>e</i> is rewritten
	as (<i>e</i> += 1), and then checking for operator overloading
	is done. The situation is analogous for --<i>e</i>.
	</p>

<h3>Examples</h3>

	<ol>
	<li><pre class="d_code"><span class="d_keyword">class</span> A { <span class="d_keyword">int</span> <b>opNeg</b>(); }
A a;
-a;	<span class="d_comment">// equivalent to a.opNeg();
</span></pre>
	</li>
	<li><pre class="d_code"><span class="d_keyword">class</span> A { <span class="d_keyword">int</span> <b>opNeg</b>(<span class="d_keyword">int</span> i); }
A a;
-a;	<span class="d_comment">// equivalent to a.opNeg(), which is an error
</span></pre>
	</li>
	</ol>

<h3>Overloading cast(<i>type</i>)<i>e</i></h3>

	<p>The member function <i>e</i>.<b>opCast()</b> is called,
	and the return value of <b>opCast()</b> is implicitly converted
	to <i>type</i>. Since functions cannot be overloaded based on
	return value, there can be only one <b>opCast</b> per struct or
	class.
	Overloading the cast operator does not affect implicit casts, it
	only applies to explicit casts.
	</p>

<pre class="d_code"><span class="d_keyword">struct</span> A
{
    <span class="d_keyword">int</span> <b>opCast</b>() { <span class="d_keyword">return</span> 28; }
}

<span class="d_keyword">void</span> test()
{
    A a;

    <span class="d_keyword">long</span> i = <span class="d_keyword">cast</span>(<span class="d_keyword">long</span>)a;   <span class="d_comment">// i is set to 28L
</span>    <span class="d_keyword">void</span>* p = <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)a; <span class="d_comment">// error, cannot implicitly
</span>			    <span class="d_comment">// convert int to void*
</span>    <span class="d_keyword">int</span> j = a;		    <span class="d_comment">// error, cannot implicitly convert
</span>			    <span class="d_comment">// A to int
</span>}
</pre>

<h2>Binary Operator Overloading</h2>


	<table border=1 cellpadding=4 cellspacing=0>	<caption>Overloadable Binary Operators</caption>

	<tr><th><i>op</i></th>
	<th>commutative?</th>
	<th><i>opfunc</i></th>
	<th><i>opfunc_r</i></th>
	</tr>

	<tr><td>+</td> <td>yes</td> <td><tt>opAdd</tt></td> <td><tt>opAdd_r</tt></td></tr>

	<tr><td>-</td> <td>no</td> <td><tt>opSub</tt></td> <td><tt>opSub_r</tt></td></tr>

	<tr><td>*</td> <td>yes</td> <td><tt>opMul</tt></td> <td><tt>opMul_r</tt></td></tr>

	<tr><td>/</td> <td>no</td> <td><tt>opDiv</tt></td> <td><tt>opDiv_r</tt></td></tr>

	<tr><td>%</td> <td>no</td> <td><tt>opMod</tt></td> <td><tt>opMod_r</tt></td></tr>

	<tr><td>&amp;</td> <td>yes</td> <td><tt>opAnd</tt></td> <td><tt>opAnd_r</tt></td></tr>

	<tr><td>|</td> <td>yes</td> <td><tt>opOr</tt></td> <td><tt>opOr_r</tt></td></tr>

	<tr><td>^</td> <td>yes</td> <td><tt>opXor</tt></td> <td><tt>opXor_r</tt></td></tr>

	<tr><td>&lt;&lt;</td> <td>no</td> <td><tt>opShl</tt></td> <td><tt>opShl_r</tt></td></tr>

	<tr><td>&gt;&gt;</td> <td>no</td> <td><tt>opShr</tt></td> <td><tt>opShr_r</tt></td></tr>

	<tr><td>&gt;&gt;&gt;</td> <td>no</td> <td><tt>opUShr</tt></td> <td><tt>opUShr_r</tt></td></tr>

	<tr><td>~</td> <td>no</td> <td><tt>opCat</tt></td> <td><tt>opCat_r</tt></td></tr>

	<tr><td>==</td> <td>yes</td> <td><tt>opEquals</tt></td> <td>-</td></tr>

	<tr><td>!=</td> <td>yes</td> <td><tt>opEquals</tt></td> <td>-</td></tr>

	<tr><td>&lt;</td> <td>yes</td> <td><tt>opCmp</tt></td> <td>-</td></tr>

	<tr><td>&lt;=</td> <td>yes</td> <td><tt>opCmp</tt></td> <td>-</td></tr>

	<tr><td>&gt;</td> <td>yes</td> <td><tt>opCmp</tt></td> <td>-</td></tr>

	<tr><td>&gt;=</td> <td>yes</td> <td><tt>opCmp</tt></td> <td>-</td></tr>

	<tr><td>=</td> <td>no </td> <td><tt>opAssign</tt></td> <td>-</td> </tr>

	<tr><td>+=</td> <td>no</td> <td><tt>opAddAssign</tt></td> <td>-</td></tr>

	<tr><td>-=</td> <td>no</td> <td><tt>opSubAssign</tt></td> <td>-</td></tr>

	<tr><td>*=</td> <td>no</td> <td><tt>opMulAssign</tt></td> <td>-</td></tr>

	<tr><td>/=</td> <td>no</td> <td><tt>opDivAssign</tt></td> <td>-</td></tr>

	<tr><td>%=</td> <td>no</td> <td><tt>opModAssign</tt></td> <td>-</td></tr>

	<tr><td>&amp;=</td> <td>no</td> <td><tt>opAndAssign</tt></td> <td>-</td></tr>

	<tr><td>|=</td> <td>no</td> <td><tt>opOrAssign</tt></td> <td>-</td></tr>

	<tr><td>^=</td> <td>no</td> <td><tt>opXorAssign</tt></td> <td>-</td></tr>

	<tr><td>&lt;&lt;=</td> <td>no</td> <td><tt>opShlAssign</tt></td> <td>-</td></tr>

	<tr><td>&gt;&gt;=</td> <td>no</td> <td><tt>opShrAssign</tt></td> <td>-</td></tr>

	<tr><td>&gt;&gt;&gt;=</td> <td>no</td> <td><tt>opUShrAssign</tt></td> <td>-</td></tr>

	<tr><td>~=</td> <td>no</td> <td><tt>opCatAssign</tt></td> <td>-</td></tr>

	<tr><td>in </td> <td>no </td> <td><tt>opIn</tt> </td> <td><tt>opIn_r</tt> </td></tr>

	</table>

	<p>Given a binary
	overloadable operator <i>op</i> and its corresponding
	class or struct member
	function name <i>opfunc</i> and <i>opfunc_r</i>,
	and the syntax:
	</p>

<pre class="d_code">a <i>op</i> b
</pre>

	the following sequence of rules is applied, in order, to determine
	which form is used:

	<ol>
	<li>The expression is rewritten as both:
<pre class="d_code">a.<i>opfunc</i>(b)
b.<i>opfunc_r</i>(a)
</pre>
	If any <i>a.opfunc</i> or <i>b.opfunc_r</i> functions exist,
	then overloading is applied
	across all of them and the best match is used. If either exist,
	and there is no argument match, then it is an error.
	</li>

	<li>If the operator is commutative, then the following
	forms are tried:
<pre class="d_code">a.<i>opfunc_r</i>(b)
b.<i>opfunc</i>(a)
</pre>
	</li>

	<li>If <i>a</i> or <i>b</i> is a struct or class object reference,
	it is an error.
	</li>
	</ol>

<h4>Examples</h4>

	<ol>
	<li>
<pre class="d_code"><span class="d_keyword">class</span> A { <span class="d_keyword">int</span> <b>opAdd</b>(<span class="d_keyword">int</span> i); }
A a;
a + 1;	<span class="d_comment">// equivalent to a.opAdd(1)
</span>1 + a;	<span class="d_comment">// equivalent to a.opAdd(1)
</span></pre>
	</li>
	<li>
<pre class="d_code"><span class="d_keyword">class</span> B { <span class="d_keyword">int</span> <b>opDiv_r</b>(<span class="d_keyword">int</span> i); }
B b;
1 / b;	<span class="d_comment">// equivalent to b.opDiv_r(1)
</span></pre>
	</li>
	<li><pre class="d_code"><span class="d_keyword">class</span> A { <span class="d_keyword">int</span> <b>opAdd</b>(<span class="d_keyword">int</span> i); }
<span class="d_keyword">class</span> B { <span class="d_keyword">int</span> <b>opAdd_r</b>(A a); }
A a;
B b;
a + 1;	<span class="d_comment">// equivalent to a.opAdd(1)
</span>a + b;	<span class="d_comment">// equivalent to b.opAdd_r(a)
</span>b + a;	<span class="d_comment">// equivalent to b.opAdd_r(a)
</span></pre>
	</li>
	<li><pre class="d_code"><span class="d_keyword">class</span> A { <span class="d_keyword">int</span> <b>opAdd</b>(B b);  <span class="d_keyword">int</span> <b>opAdd_r</b>(B b); }
<span class="d_keyword">class</span> B { }
A a;
B b;
a + b;	<span class="d_comment">// equivalent to a.opAdd(b)
</span>b + a;	<span class="d_comment">// equivalent to a.opAdd_r(b)
</span></pre>
	</li>
	<li><pre class="d_code"><span class="d_keyword">class</span> A { <span class="d_keyword">int</span> <b>opAdd</b>(B b);  <span class="d_keyword">int</span> <b>opAdd_r</b>(B b); }
<span class="d_keyword">class</span> B { <span class="d_keyword">int</span> <b>opAdd_r</b>(A a); }
A a;
B b;
a + b;	<span class="d_comment">// ambiguous: a.opAdd(b) or b.opAdd_r(a)
</span>b + a;	<span class="d_comment">// equivalent to a.opAdd_r(b)
</span></pre>
	</li>
	</ol>

<h3>Overloading == and !=</h3>

	<p>Both operators use the <tt><b>opEquals</b>()</tt> function.
	The expression
	<tt>(a == b)</tt> is rewritten as <tt>a.<b>opEquals</b>(b)</tt>,
	and <tt>(a != b)</tt> is rewritten as <tt>!a.<b>opEquals</b>(b)</tt>.
	</p>

	<p>The member function <tt><b>opEquals</b>()</tt> is defined as part of
	Object as:
	</p>

<pre class="d_code"><span class="d_keyword">int</span> <b>opEquals</b>(Object o);
</pre>

	<p>so that every class object has a default <tt><b>opEquals</b>()</tt>.
	But every class definition which will be using == or != should
	expect to need to override opEquals. The parameter to the overriding
	function must be of type <tt>Object</tt>, not the type for the class.
	</p>

	<p>Structs and unions (hereafter just called structs) can
	provide a member function:
	</p>

<pre class="d_code"><span class="d_keyword">int</span> <b>opEquals</b>(S s)
</pre>
	<p>or:</p>
<pre class="d_code"><span class="d_keyword">int</span> <b>opEquals</b>(S* s)
</pre>

	<p>where <tt>S</tt> is the struct name, to define how equality is
	determined.</p>

	<p>If a struct has no <b>opEquals</b> function declared for it,
	a bit compare of the contents of the two structs is done to
	determine equality or inequality.
	</p>

	<p><b>Note:</b> Comparing a reference to a class object against <b>null</b>
	should be done as:
	</p>
<pre class="d_code"><span class="d_keyword">if</span> (a <span class="d_keyword">is</span> <span class="d_keyword">null</span>)
</pre>
	<p>and not as:</p>
<pre class="d_code"><span class="d_keyword">if</span> (a == <span class="d_keyword">null</span>)
</pre>
	<p>The latter is converted to:</p>
<pre class="d_code"><span class="d_keyword">if</span> (a.<b>opEquals</b>(<span class="d_keyword">null</span>))
</pre>
	<p>which will fail if <tt><b>opEquals</b>()</tt> is a virtual function.</p>

<h3>Overloading &lt;, &lt;=, &gt; and &gt;=</h3>

	<p>These comparison operators all use the <tt><b>opCmp</b>()</tt> function.
	The expression
	<tt>(a <i>op</i> b)</tt> is rewritten as <tt>(a.<b>opCmp</b>(b) <i>op</i> 0)</tt>.
	The commutative operation is rewritten as <tt>(0 <i>op</i> b.<b>opCmp</b>(a))</tt>
	</p>

	<p>The member function <tt><b>opCmp</b>()</tt> is defined as part of Object
	as:
	</p>

<pre class="d_code"><span class="d_keyword">int</span> <b>opCmp</b>(Object o);
</pre>

	<p>so that every class object has a <tt><b>opCmp</b>()</tt>.
	</p>

	<p><tt><b>opCmp</b></tt> for structs works analogously to
	<tt><b>opEquals</b></tt> for structs:
	</p>
<pre class="d_code"><span class="d_keyword">struct</span> Pair
{
    <span class="d_keyword">int</span> a, b;
    <span class="d_keyword">int</span> <b>opCmp</b>(Pair rhs)
    {
        <span class="d_keyword">if</span> (a!=rhs.a) <span class="d_keyword">return</span> a-rhs.a;
        <span class="d_keyword">return</span> b-rhs.b;
    }
}
</pre>

	<p>If a struct has no <tt><b>opCmp</b>()</tt> function declared for it,
	attempting
	to compare two structs is an error.
	</p>

<h4>Rationale</h4>

	<p>The reason for having both <tt><b>opEquals</b></tt> and
	<tt><b>opCmp</b></tt> is that:</p>

	<ul>	<li>Testing for equality can sometimes be a much more efficient
	operation than testing for less or greater than.</li>
	<li>Having an <tt><b>opCmp</b></tt> defined in <tt>Object</tt>
	makes it possible to
	make associative arrays work generically for classes.</li>
	<li>For some objects, testing for less or greater makes no sense.
	This is why <tt>Object.<b>opCmp</b></tt> throws a runtime error.
	<tt><b>opCmp</b></tt> must be overridden in each class for which comparison
	makes sense.</li>
	</ul>

	<p>The parameter to <b>opEquals</b> and <b>opCmp</b>
	for class definitions must
	be of type <tt>Object</tt>, rather than the type of the particular class,
	in order to override the <tt>Object.<b>opEquals</b></tt> and
	<tt>Object.<b>opCmp</b></tt>
	functions properly.
	</p>

<h2>Function Call Operator Overloading <i>f</i>()</h2>

	<p>The function call operator, (), can be overloaded by
	declaring a function named <b>opCall</b>:
	</p>

<pre class="d_code"><span class="d_keyword">struct</span> F
{
    <span class="d_keyword">int</span> <b>opCall</b>();
    <span class="d_keyword">int</span> <b>opCall</b>(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, <span class="d_keyword">int</span> z);
}

<span class="d_keyword">void</span> test()
{   F f;
    <span class="d_keyword">int</span> i;

    i = f<b>()</b>;		<span class="d_comment">// same as i = f.opCall();
</span>    i = f<b>(3,4,5)</b>;	<span class="d_comment">// same as i = f.opCall(3,4,5);
</span>}
</pre>

	<p>In this way a struct or class object can behave as if it
	were a function.
	</p>

<h2>Array Operator Overloading</h2>

<h3>Overloading Indexing <i>a</i>[<i>i</i>]</h3>

	<p>The array index operator, [], can be overloaded by
	declaring a function named <b>opIndex</b> with one
	or more parameters.
	Assignment to an array can be overloaded with a function
	named <b>opIndexAssign</b> with two or more parameters.
	The first parameter is the rvalue of the assignment expression.
	</p>

<pre class="d_code"><span class="d_keyword">struct</span> A
{
    <span class="d_keyword">int</span> <b>opIndex</b>(size_t i1, size_t i2, size_t i3);
    <span class="d_keyword">int</span> <b>opIndexAssign</b>(<span class="d_keyword">int</span> value, size_t i1, size_t i2);
}

<span class="d_keyword">void</span> test()
{   A a;
    <span class="d_keyword">int</span> i;

    i = a<b>[</b>5,6,7<b>]</b>;	<span class="d_comment">// same as i = a.opIndex(5,6,7);
</span>    a<b>[</b>i,3<b>]</b> = 7;		<span class="d_comment">// same as a.opIndexAssign(7,i,3);
</span>}
</pre>

	<p>In this way a struct or class object can behave as if it
	were an array.
	</p>

	<p><b>Note:</b> Array index overloading currently does not
	work for the lvalue of an <i>op</i>=, ++, or -- operator.
	</p>


<h3>Overloading Slicing <i>a</i>[] and <i>a</i>[<i>i</i> .. <i>j</i>]</h3>

	<p>Overloading the slicing operator means overloading expressions
	like <tt>a[]</tt> and <tt>a[i .. j]</tt>.
	This can be done by declaring a function named <b>opSlice</b>.
	Assignment to a slice can be done by declaring <b>opSliceAssign</b>.
	</p>

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> <b>opSlice</b>();		 		  <span class="d_comment">// overloads a[]
</span>    <span class="d_keyword">int</span> <b>opSlice</b>(size_t x, size_t y);		  <span class="d_comment">// overloads a[i .. j]
</span>
    <span class="d_keyword">int</span> <b>opSliceAssign</b>(<span class="d_keyword">int</span> v);			  <span class="d_comment">// overloads a[] = v
</span>    <span class="d_keyword">int</span> <b>opSliceAssign</b>(<span class="d_keyword">int</span> v, size_t x, size_t y); <span class="d_comment">// overloads a[i .. j] = v
</span>}

<span class="d_keyword">void</span> test()
{   A a = <span class="d_keyword">new</span> A();
    <span class="d_keyword">int</span> i;
    <span class="d_keyword">int</span> v;

    i = a<b>[]</b>;		<span class="d_comment">// same as i = a.opSlice();
</span>    i = a<b>[</b>3..4<b>]</b>;	<span class="d_comment">// same as i = a.opSlice(3,4);
</span>
    a<b>[]</b> = v;		<span class="d_comment">// same as a.opSliceAssign(v);
</span>    a<b>[</b>3..4<b>]</b> = v;	<span class="d_comment">// same as a.opSliceAssign(v,3,4);
</span>}
</pre>

<h2>Assignment Operator Overloading</h2>

	<p>The assignment operator <tt>=</tt> can be overloaded if the
	lvalue is a struct  aggregate, and <tt>opAssign</tt>
	is a member function of that aggregate.</p>

	<p>The assignment operator cannot be overloaded for rvalues
	that can be implicitly cast to the lvalue type.
	Furthermore, the following parameter signatures for <tt>opAssign</tt>
	are not allowed:</p>

<pre class="d_code">opAssign(...)
opAssign(T)
opAssign(T, ...)
opAssign(T ...)
opAssign(T, U = defaultValue, etc.)
</pre>

	<p>where <i>T</i> is the same type as the aggregate type <i>A</i>,
	is implicitly
	convertible to <i>A</i>, or if <i>A</i> is a struct and <i>T</i>
	is a pointer to a type that is
	implicitly convertible to <i>A</i>.
	</p>

<h2>Future Directions</h2>

	<p>The operators <tt>! . &amp;&amp; || ?:</tt> and a few others will
	likely never be overloadable.
	</p>

  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>




<div id="copyright">

Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/OperatorOverloading
" title="Read/write comments and feedback">Comments</a>
</div>

</body>
</html>

