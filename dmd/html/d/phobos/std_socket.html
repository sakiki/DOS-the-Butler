<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.socket - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        newText += '<a href="#' + a.name + '"><span class="d_psymbol">'
                + a.name + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="../dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>


	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Phobos/StdSocket" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="../index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:45:45 2008
</div>
</div>



<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std_bitarray.html" title="Arrays of bits">std.bitarray</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_iterator.html" title="Defines iterators and ranges">std.iterator</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_openrj.html" title="Basic database">std.openrj</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_regexp.html" title="regular expressions">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
</div>

</div>
<div id="content">
    <h1>std.socket</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\socket.d -->
<b>Notes:</b><br>
For Win32 systems, link with ws2_32.lib.
<br><br>
<b>Example:</b><br>
See /dmd/samples/d/listener.d.
<br><br>
<b>Authors:</b><br>
Christopher E. Miller
<br><br>

<dl><dt><div class="d_decl">class <a name="SocketException"></a><u>SocketException</u>: object.Exception;
</div></dt>
<dd>Base exception thrown from a Socket.
<br><br>

<dl><dt><div class="d_decl">int <a name="errorCode"></a><u>errorCode</u>;
</div></dt>
<dd>Platform-specific error code.
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="AddressFamily"></a><u>AddressFamily</u>;
</div></dt>
<dd>The communication domain used to resolve an address.
 
<br><br>

<dl><dt><div class="d_decl"><a name="UNSPEC"></a><u>UNSPEC</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="UNIX"></a><u>UNIX</u></div></dt>
<dd>local communication
<br><br>

</dd>
<dt><div class="d_decl"><a name="INET"></a><u>INET</u></div></dt>
<dd>internet protocol version 4
<br><br>

</dd>
<dt><div class="d_decl"><a name="IPX"></a><u>IPX</u></div></dt>
<dd>novell <a name="IPX"></a><u>IPX</u>
<br><br>

</dd>
<dt><div class="d_decl"><a name="APPLETALK"></a><u>APPLETALK</u></div></dt>
<dd>appletalk
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="SocketType"></a><u>SocketType</u>;
</div></dt>
<dd>Communication semantics
 
<br><br>

<dl><dt><div class="d_decl"><a name="STREAM"></a><u>STREAM</u></div></dt>
<dd>sequenced, reliable, two-way communication-based byte streams
<br><br>

</dd>
<dt><div class="d_decl"><a name="DGRAM"></a><u>DGRAM</u></div></dt>
<dd>connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order
<br><br>

</dd>
<dt><div class="d_decl"><a name="RAW"></a><u>RAW</u></div></dt>
<dd>raw protocol access
<br><br>

</dd>
<dt><div class="d_decl"><a name="RDM"></a><u>RDM</u></div></dt>
<dd>reliably-delivered message datagrams
<br><br>

</dd>
<dt><div class="d_decl"><a name="SEQPACKET"></a><u>SEQPACKET</u></div></dt>
<dd>sequenced, reliable, two-way connection-based datagrams with a fixed maximum length
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="ProtocolType"></a><u>ProtocolType</u>;
</div></dt>
<dd>Protocol
 
<br><br>

<dl><dt><div class="d_decl"><a name="IP"></a><u>IP</u></div></dt>
<dd>internet protocol version 4
<br><br>

</dd>
<dt><div class="d_decl"><a name="ICMP"></a><u>ICMP</u></div></dt>
<dd>internet control message protocol
<br><br>

</dd>
<dt><div class="d_decl"><a name="IGMP"></a><u>IGMP</u></div></dt>
<dd>internet group management protocol
<br><br>

</dd>
<dt><div class="d_decl"><a name="GGP"></a><u>GGP</u></div></dt>
<dd>gateway to gateway protocol
<br><br>

</dd>
<dt><div class="d_decl"><a name="TCP"></a><u>TCP</u></div></dt>
<dd>transmission control protocol
<br><br>

</dd>
<dt><div class="d_decl"><a name="PUP"></a><u>PUP</u></div></dt>
<dd>PARC universal packet protocol
<br><br>

</dd>
<dt><div class="d_decl"><a name="UDP"></a><u>UDP</u></div></dt>
<dd>user datagram protocol
<br><br>

</dd>
<dt><div class="d_decl"><a name="IDP"></a><u>IDP</u></div></dt>
<dd>Xerox NS protocol
<br><br>

</dd>
<dt><div class="d_decl"><a name="IPV6"></a><u>IPV6</u></div></dt>
<dd>internet protocol version 6
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="Protocol"></a><u>Protocol</u>;
</div></dt>
<dd><a name="Protocol"></a><u>Protocol</u> is a class for retrieving protocol information.
 
<br><br>

<dl><dt><div class="d_decl">ProtocolType <a name="type"></a><u>type</u>;
<br>string <a name="name"></a><u>name</u>;
<br>invariant(char)[][] <a name="aliases"></a><u>aliases</u>;
</div></dt>
<dd>These members are populated when one of the following functions are called without failure:
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="getProtocolByName"></a><u>getProtocolByName</u>(string <i>name</i>);
</div></dt>
<dd>Returns <b>false</b> on failure 
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="getProtocolByType"></a><u>getProtocolByType</u>(ProtocolType <i>type</i>);
</div></dt>
<dd>Returns <b>false</b> on failure 
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="Service"></a><u>Service</u>;
</div></dt>
<dd><a name="Service"></a><u>Service</u> is a class for retrieving service information.
 
<br><br>

<dl><dt><div class="d_decl">string <a name="name"></a><u>name</u>;
<br>invariant(char)[][] <a name="aliases"></a><u>aliases</u>;
<br>ushort <a name="port"></a><u>port</u>;
<br>string <a name="protocolName"></a><u>protocolName</u>;
</div></dt>
<dd>These members are populated when one of the following functions are called without failure: 
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="getServiceByName"></a><u>getServiceByName</u>(string <i>name</i>, string <i>protocolName</i>);
<br>bool <a name="getServiceByName"></a><u>getServiceByName</u>(string <i>name</i>);
<br>bool <a name="getServiceByPort"></a><u>getServiceByPort</u>(ushort <i>port</i>, string <i>protocolName</i>);
<br>bool <a name="getServiceByPort"></a><u>getServiceByPort</u>(ushort <i>port</i>);
</div></dt>
<dd>If a protocol <i>name</i> is omitted, any protocol will be matched.
<br><br>
<b>Returns:</b><br>
<b>false</b> on failure.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="HostException"></a><u>HostException</u>: object.Exception;
</div></dt>
<dd>Base exception thrown from an InternetHost.
 
<br><br>

<dl><dt><div class="d_decl">int <a name="errorCode"></a><u>errorCode</u>;
</div></dt>
<dd>Platform-specific error code.
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="InternetHost"></a><u>InternetHost</u>;
</div></dt>
<dd><a name="InternetHost"></a><u>InternetHost</u> is a class for resolving IPv4 addresses.
 
<br><br>

<dl><dt><div class="d_decl">string <a name="name"></a><u>name</u>;
<br>invariant(char)[][] <a name="aliases"></a><u>aliases</u>;
<br>uint[] <a name="addrList"></a><u>addrList</u>;
</div></dt>
<dd>These members are populated when one of the following functions are called without failure: 
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="getHostByName"></a><u>getHostByName</u>(string <i>name</i>);
</div></dt>
<dd>Resolve host <i>name</i>. Returns <b>false</b> if unable to resolve.
	 
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="getHostByAddr"></a><u>getHostByAddr</u>(uint <i>addr</i>);
</div></dt>
<dd>Resolve IPv4 address number. Returns <b>false</b> if unable to resolve.
	 
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="getHostByAddr"></a><u>getHostByAddr</u>(string <i>addr</i>);
</div></dt>
<dd>Same as previous, but <i>addr</i> is an IPv4 address string in the
 dotted-decimal form <i>a.b.c.d</i>.
 Returns <b>false</b> if unable to resolve.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="AddressException"></a><u>AddressException</u>: object.Exception;
</div></dt>
<dd>Base exception thrown from an Address.
 
<br><br>

<dl></dl>
</dd>
<dt><div class="d_decl">class <a name="Address"></a><u>Address</u>;
</div></dt>
<dd><a name="Address"></a><u>Address</u> is an abstract class for representing a network addresses.
 
<br><br>

<dl><dt><div class="d_decl">AddressFamily <a name="addressFamily"></a><u>addressFamily</u>();
</div></dt>
<dd>Family of this address.
<br><br>

</dd>
<dt><div class="d_decl">string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Human readable string representing this address.
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="UnknownAddress"></a><u>UnknownAddress</u>: std.socket.Address;
</div></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><div class="d_decl">class <a name="InternetAddress"></a><u>InternetAddress</u>: std.socket.Address;
</div></dt>
<dd><a name="InternetAddress"></a><u>InternetAddress</u> is a class that represents an IPv4 (internet protocol version
 4) address and port.
 
<br><br>

<dl><dt><div class="d_decl">const uint <a name="ADDR_ANY"></a><u>ADDR_ANY</u>;
</div></dt>
<dd>Any IPv4 address number.
<br><br>

</dd>
<dt><div class="d_decl">const uint <a name="ADDR_NONE"></a><u>ADDR_NONE</u>;
</div></dt>
<dd>An invalid IPv4 address number.
<br><br>

</dd>
<dt><div class="d_decl">const ushort <a name="PORT_ANY"></a><u>PORT_ANY</u>;
</div></dt>
<dd>Any IPv4 port number.
<br><br>

</dd>
<dt><div class="d_decl">AddressFamily <a name="addressFamily"></a><u>addressFamily</u>();
</div></dt>
<dd>Overridden to return AddressFamily.INET.
<br><br>

</dd>
<dt><div class="d_decl">ushort <a name="port"></a><u>port</u>();
</div></dt>
<dd>Returns the IPv4 <a name="port"></a><u>port</u> number.
<br><br>

</dd>
<dt><div class="d_decl">uint <a name="addr"></a><u>addr</u>();
</div></dt>
<dd>Returns the IPv4 address number.
<br><br>

</dd>
<dt><div class="d_decl">this(string <i>addr</i>, ushort <i>port</i>);
</div></dt>
<dd><b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>addr</i></td>
<td>an IPv4 address string in the dotted-decimal form a.b.c.d,
          or a host name that will be resolved using an InternetHost
          object.</td></tr>
<tr><td>ushort <i>port</i></td>
<td>may be PORT_ANY as stated below.</td></tr>
</table><br>

</dd>
<dt><div class="d_decl">this(uint <i>addr</i>, ushort <i>port</i>);
<br>this(ushort <i>port</i>);
</div></dt>
<dd>Construct a new Address. <i>addr</i> may be ADDR_ANY (default) and <i>port</i> may
 be PORT_ANY, and the actual numbers may not be known until a connection
 is made.
	 
<br><br>

</dd>
<dt><div class="d_decl">string <a name="toAddrString"></a><u>toAddrString</u>();
</div></dt>
<dd>Human readable string representing the IPv4 address in dotted-decimal form.	
<br><br>

</dd>
<dt><div class="d_decl">string <a name="toPortString"></a><u>toPortString</u>();
</div></dt>
<dd>Human readable string representing the IPv4 port.
<br><br>

</dd>
<dt><div class="d_decl">string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Human readable string representing the IPv4 address and port in the form <i>a.b.c.d:e</i>.
<br><br>

</dd>
<dt><div class="d_decl">static uint <a name="parse"></a><u>parse</u>(string <i>addr</i>);
</div></dt>
<dd>Parse an IPv4 address string in the dotted-decimal form <i>a.b.c.d</i>
 and return the number.
 If the string is not a legitimate IPv4 address,
 ADDR_NONE is returned.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="SocketAcceptException"></a><u>SocketAcceptException</u>: std.socket.SocketException;
</div></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><div class="d_decl">enum <a name="SocketShutdown"></a><u>SocketShutdown</u>;
</div></dt>
<dd>How a socket is shutdown:
<br><br>

<dl><dt><div class="d_decl"><a name="RECEIVE"></a><u>RECEIVE</u></div></dt>
<dd>socket receives are disallowed
<br><br>

</dd>
<dt><div class="d_decl"><a name="SEND"></a><u>SEND</u></div></dt>
<dd>socket sends are disallowed
<br><br>

</dd>
<dt><div class="d_decl"><a name="BOTH"></a><u>BOTH</u></div></dt>
<dd>both RECEIVE and SEND
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="SocketFlags"></a><u>SocketFlags</u>;
</div></dt>
<dd>Flags may be OR'ed together:
<br><br>

<dl><dt><div class="d_decl"><a name="NONE"></a><u>NONE</u></div></dt>
<dd>no flags specified 
<br><br>

</dd>
<dt><div class="d_decl"><a name="OOB"></a><u>OOB</u></div></dt>
<dd>out-of-band stream data
<br><br>

</dd>
<dt><div class="d_decl"><a name="PEEK"></a><u>PEEK</u></div></dt>
<dd>peek at incoming data without removing it from the queue, only for receiving
<br><br>

</dd>
<dt><div class="d_decl"><a name="DONTROUTE"></a><u>DONTROUTE</u></div></dt>
<dd>data should not be subject to routing; this flag may be ignored. Only for sending
<br><br>

</dd>
<dt><div class="d_decl"><a name="NOSIGNAL"></a><u>NOSIGNAL</u></div></dt>
<dd>don't send SIGPIPE signal on socket write error and instead return EPIPE
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="timeval"></a><u>timeval</u>;
</div></dt>
<dd>Duration timeout value.
<br><br>

<dl><dt><div class="d_decl">int <a name="seconds"></a><u>seconds</u>;
</div></dt>
<dd>Number of <a name="seconds"></a><u>seconds</u>.
<br><br>

</dd>
<dt><div class="d_decl">int <a name="microseconds"></a><u>microseconds</u>;
</div></dt>
<dd>Number of additional <a name="microseconds"></a><u>microseconds</u>.
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="SocketSet"></a><u>SocketSet</u>;
</div></dt>
<dd>A collection of sockets for use with Socket.select.
<br><br>

<dl><dt><div class="d_decl">this(uint <i>max</i>);
</div></dt>
<dd>Set the maximum amount of sockets that may be added.
<br><br>

</dd>
<dt><div class="d_decl">this();
</div></dt>
<dd>Uses the default maximum for the system.
<br><br>

</dd>
<dt><div class="d_decl">void <a name="reset"></a><u>reset</u>();
</div></dt>
<dd>Reset the SocketSet so that there are 0 Sockets in the collection.	
<br><br>

</dd>
<dt><div class="d_decl">void <a name="add"></a><u>add</u>(Socket <i>s</i>);
</div></dt>
<dd>Add a Socket to the collection. Adding more than the maximum has dangerous side affects.
<br><br>

</dd>
<dt><div class="d_decl">void <a name="remove"></a><u>remove</u>(Socket <i>s</i>);
</div></dt>
<dd>Remove this Socket from the collection.
<br><br>

</dd>
<dt><div class="d_decl">int <a name="isSet"></a><u>isSet</u>(Socket <i>s</i>);
</div></dt>
<dd>Returns nonzero if this Socket is in the collection.
<br><br>

</dd>
<dt><div class="d_decl">uint <a name="max"></a><u>max</u>();
</div></dt>
<dd>Return maximum amount of sockets that can be added, like FD_SETSIZE.
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="SocketOptionLevel"></a><u>SocketOptionLevel</u>;
</div></dt>
<dd>The level at which a socket option is defined:
<br><br>

<dl><dt><div class="d_decl"><a name="SOCKET"></a><u>SOCKET</u></div></dt>
<dd>socket level
<br><br>

</dd>
<dt><div class="d_decl"><a name="IP"></a><u>IP</u></div></dt>
<dd>internet protocol version 4 level
<br><br>

</dd>
<dt><div class="d_decl"><a name="ICMP"></a><u>ICMP</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="IGMP"></a><u>IGMP</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="GGP"></a><u>GGP</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="TCP"></a><u>TCP</u></div></dt>
<dd>transmission control protocol level
<br><br>

</dd>
<dt><div class="d_decl"><a name="PUP"></a><u>PUP</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="UDP"></a><u>UDP</u></div></dt>
<dd>user datagram protocol level
<br><br>

</dd>
<dt><div class="d_decl"><a name="IDP"></a><u>IDP</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="IPV6"></a><u>IPV6</u></div></dt>
<dd>internet protocol version 6 level
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="linger"></a><u>linger</u>;
</div></dt>
<dd>Linger information for use with SocketOption.LINGER.
<br><br>

<dl><dt><div class="d_decl">uint16_t <a name="on"></a><u>on</u>;
</div></dt>
<dd>Nonzero for <a name="on"></a><u>on</u>.
<br><br>

</dd>
<dt><div class="d_decl">uint16_t <a name="time"></a><u>time</u>;
</div></dt>
<dd>Linger <a name="time"></a><u>time</u>.
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="SocketOption"></a><u>SocketOption</u>;
</div></dt>
<dd>Specifies a socket option:
<br><br>

<dl><dt><div class="d_decl"><a name="DEBUG"></a><u>DEBUG</u></div></dt>
<dd>record debugging information
<br><br>

</dd>
<dt><div class="d_decl"><a name="BROADCAST"></a><u>BROADCAST</u></div></dt>
<dd>allow transmission of broadcast messages
<br><br>

</dd>
<dt><div class="d_decl"><a name="REUSEADDR"></a><u>REUSEADDR</u></div></dt>
<dd>allow local reuse of address
<br><br>

</dd>
<dt><div class="d_decl"><a name="LINGER"></a><u>LINGER</u></div></dt>
<dd>linger on close if unsent data is present
<br><br>

</dd>
<dt><div class="d_decl"><a name="OOBINLINE"></a><u>OOBINLINE</u></div></dt>
<dd>receive out-of-band data in band
<br><br>

</dd>
<dt><div class="d_decl"><a name="SNDBUF"></a><u>SNDBUF</u></div></dt>
<dd>send buffer size
<br><br>

</dd>
<dt><div class="d_decl"><a name="RCVBUF"></a><u>RCVBUF</u></div></dt>
<dd>receive buffer size
<br><br>

</dd>
<dt><div class="d_decl"><a name="DONTROUTE"></a><u>DONTROUTE</u></div></dt>
<dd>do not route
<br><br>

</dd>
<dt><div class="d_decl"><a name="TCP_NODELAY"></a><u>TCP_NODELAY</u></div></dt>
<dd>disable the Nagle algorithm for send coalescing
<br><br>

</dd>
<dt><div class="d_decl"><a name="IPV6_UNICAST_HOPS"></a><u>IPV6_UNICAST_HOPS</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="IPV6_MULTICAST_IF"></a><u>IPV6_MULTICAST_IF</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="IPV6_MULTICAST_LOOP"></a><u>IPV6_MULTICAST_LOOP</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="IPV6_JOIN_GROUP"></a><u>IPV6_JOIN_GROUP</u></div></dt>
<dd><br><br>
</dd>
<dt><div class="d_decl"><a name="IPV6_LEAVE_GROUP"></a><u>IPV6_LEAVE_GROUP</u></div></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="Socket"></a><u>Socket</u>;
</div></dt>
<dd><a name="Socket"></a><u>Socket</u> is a class that creates a network communication endpoint using the
 Berkeley sockets interface.
 
<br><br>

<dl><dt><div class="d_decl">this(AddressFamily <i>af</i>, SocketType <i>type</i>, ProtocolType <i>protocol</i>);
<br>this(AddressFamily <i>af</i>, SocketType <i>type</i>);
<br>this(AddressFamily <i>af</i>, SocketType <i>type</i>, string <i>protocolName</i>);
</div></dt>
<dd>Create a blocking socket. If a single <i>protocol</i> <i>type</i> exists to support
 this socket <i>type</i> within the address family, the ProtocolType may be
 omitted.
	 
<br><br>

</dd>
<dt><div class="d_decl">socket_t <a name="handle"></a><u>handle</u>();
</div></dt>
<dd>Get underlying socket <a name="handle"></a><u>handle</u>.
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="blocking"></a><u>blocking</u>();
<br>void <a name="blocking"></a><u>blocking</u>(bool <i>byes</i>);
</div></dt>
<dd>Get/set socket's <a name="blocking"></a><u>blocking</u> flag.
<br><br>
When a socket is <a name="blocking"></a><u>blocking</u>, calls to receive(), accept(), and send()
 will block and wait for data/action.
 A non-<a name="blocking"></a><u>blocking</u> socket will immediately return instead of <a name="blocking"></a><u>blocking</u>.
	 
<br><br>

</dd>
<dt><div class="d_decl">AddressFamily <a name="addressFamily"></a><u>addressFamily</u>();
</div></dt>
<dd>Get the socket's address family.	
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="isAlive"></a><u>isAlive</u>();
</div></dt>
<dd>Property that indicates if this is a valid, alive socket.
<br><br>

</dd>
<dt><div class="d_decl">void <a name="bind"></a><u>bind</u>(Address <i>addr</i>);
</div></dt>
<dd>Associate a local address with this socket.
<br><br>

</dd>
<dt><div class="d_decl">void <a name="connect"></a><u>connect</u>(Address <i>to</i>);
</div></dt>
<dd>Establish a connection. If the socket is blocking, <a name="connect"></a><u>connect</u> waits for
 the connection <i>to</i> be made. If the socket is nonblocking, <a name="connect"></a><u>connect</u>
 returns immediately and the connection attempt is still in progress.
	 
<br><br>

</dd>
<dt><div class="d_decl">void <a name="listen"></a><u>listen</u>(int <i>backlog</i>);
</div></dt>
<dd>Listen for an incoming connection. bind must be called before you can
 <a name="listen"></a><u>listen</u>. The <i>backlog</i> is a request of how many pending incoming
 connections are queued until accept'ed.
	 
<br><br>

</dd>
<dt><div class="d_decl">protected Socket <a name="accepting"></a><u>accepting</u>();
</div></dt>
<dd>Called by accept when a new Socket must be created for a new
 connection. To use a derived class, override this method and return an
 instance of your class. The returned Socket's handle must not be set;
 Socket has a protected constructor this() to use in this situation.
	 
<br><br>

</dd>
<dt><div class="d_decl">Socket <a name="accept"></a><u>accept</u>();
</div></dt>
<dd>Accept an incoming connection. If the socket is blocking, <a name="accept"></a><u>accept</u>
 waits for a connection request. Throws SocketAcceptException if unable
 to <a name="accept"></a><u>accept</u>. See accepting for use with derived classes.
	 
<br><br>

</dd>
<dt><div class="d_decl">void <a name="shutdown"></a><u>shutdown</u>(SocketShutdown <i>how</i>);
</div></dt>
<dd>Disables sends and/or receives.
<br><br>

</dd>
<dt><div class="d_decl">void <a name="close"></a><u>close</u>();
</div></dt>
<dd>Immediately drop any connections and release socket resources.
 Calling shutdown before <a name="close"></a><u>close</u> is recommended for connection-oriented
 sockets. The Socket object is no longer usable after <a name="close"></a><u>close</u>.
	 
<br><br>

</dd>
<dt><div class="d_decl">static string <a name="hostName"></a><u>hostName</u>();
</div></dt>
<dd>Returns the local machine's host name. Idea from mango.
<br><br>

</dd>
<dt><div class="d_decl">Address <a name="remoteAddress"></a><u>remoteAddress</u>();
</div></dt>
<dd>Remote endpoint Address.
<br><br>

</dd>
<dt><div class="d_decl">Address <a name="localAddress"></a><u>localAddress</u>();
</div></dt>
<dd>Local endpoint Address.
<br><br>

</dd>
<dt><div class="d_decl">const int <a name="ERROR"></a><u>ERROR</u>;
</div></dt>
<dd>Send or receive error code.
<br><br>

</dd>
<dt><div class="d_decl">int <a name="send"></a><u>send</u>(const(void)[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <a name="send"></a><u>send</u>(const(void)[] <i>buf</i>);
</div></dt>
<dd>Send data on the connection. Returns the number of bytes actually
 sent, or ERROR on failure. If the socket is blocking and there is no
 buffer space left, <a name="send"></a><u>send</u> waits.
	 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="sendTo"></a><u>sendTo</u>(const(void)[] <i>buf</i>, SocketFlags <i>flags</i>, Address <i>to</i>);
<br>int <a name="sendTo"></a><u>sendTo</u>(const(void)[] <i>buf</i>, Address <i>to</i>);
<br>int <a name="sendTo"></a><u>sendTo</u>(const(void)[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <a name="sendTo"></a><u>sendTo</u>(const(void)[] <i>buf</i>);
</div></dt>
<dd>Send data <i>to</i> a specific destination Address. If the destination address is not specified, a connection must have been made and that address is used. If the socket is blocking and there is no buffer space left, <a name="sendTo"></a><u>sendTo</u> waits.
	 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="receive"></a><u>receive</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <a name="receive"></a><u>receive</u>(void[] <i>buf</i>);
</div></dt>
<dd>Receive data on the connection. Returns the number of bytes actually
 received, 0 if the remote side has closed the connection, or ERROR on
 failure. If the socket is blocking, <a name="receive"></a><u>receive</u> waits until there is data
 to be received.
	 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="receiveFrom"></a><u>receiveFrom</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>, out Address <i>from</i>);
<br>int <a name="receiveFrom"></a><u>receiveFrom</u>(void[] <i>buf</i>, out Address <i>from</i>);
<br>int <a name="receiveFrom"></a><u>receiveFrom</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <a name="receiveFrom"></a><u>receiveFrom</u>(void[] <i>buf</i>);
</div></dt>
<dd>Receive data and get the remote endpoint Address.
 If the socket is blocking, <a name="receiveFrom"></a><u>receiveFrom</u> waits until there is data to
 be received.
<br><br>
<b>Returns:</b><br>
the number of bytes actually received,
 0 if the remote side has closed the connection, or ERROR on failure.
	 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="getOption"></a><u>getOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, void[] <i>result</i>);
</div></dt>
<dd>Get a socket <i>option</i>. Returns the number of bytes written to <i>result</i>.	
<br><br>

</dd>
<dt><div class="d_decl">int <a name="getOption"></a><u>getOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, out int32_t <i>result</i>);
</div></dt>
<dd>Common case of getting integer and boolean options.	
<br><br>

</dd>
<dt><div class="d_decl">int <a name="getOption"></a><u>getOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, out linger <i>result</i>);
</div></dt>
<dd>Get the linger <i>option</i>.	
<br><br>

</dd>
<dt><div class="d_decl">void <a name="setOption"></a><u>setOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, int32_t <i>value</i>);
</div></dt>
<dd>Common case for setting integer and boolean options.
<br><br>

</dd>
<dt><div class="d_decl">void <a name="setOption"></a><u>setOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, linger <i>value</i>);
</div></dt>
<dd>Set the linger <i>option</i>.
<br><br>

</dd>
<dt><div class="d_decl">static int <a name="select"></a><u>select</u>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>, timeval* <i>tv</i>);
<br>static int <a name="select"></a><u>select</u>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>, int <i>microseconds</i>);
<br>static int <a name="select"></a><u>select</u>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>);
</div></dt>
<dd>Wait for a socket to change status. A wait timeout timeval or int microseconds may be specified; if a timeout is not specified or the timeval is <b>null</b>, the maximum timeout is used. The timeval timeout has an unspecified value when <a name="select"></a><u>select</u> returns. Returns the number of sockets with status changes, 0 on timeout, or -1 on interruption. If the return value is greater than 0, the SocketSets are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="TcpSocket"></a><u>TcpSocket</u>: std.socket.Socket;
</div></dt>
<dd><a name="TcpSocket"></a><u>TcpSocket</u> is a shortcut class for a TCP Socket.
<br><br>

<dl><dt><div class="d_decl">this(AddressFamily <i>family</i>);
</div></dt>
<dd>Constructs a blocking TCP Socket.
<br><br>

</dd>
<dt><div class="d_decl">this();
</div></dt>
<dd>Constructs a blocking TCP Socket.
<br><br>

</dd>
<dt><div class="d_decl">this(Address <i>connectTo</i>);
</div></dt>
<dd>Constructs a blocking TCP Socket and connects to an InternetAddress.
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="UdpSocket"></a><u>UdpSocket</u>: std.socket.Socket;
</div></dt>
<dd><a name="UdpSocket"></a><u>UdpSocket</u> is a shortcut class for a UDP Socket.
<br><br>

<dl><dt><div class="d_decl">this(AddressFamily <i>family</i>);
</div></dt>
<dd>Constructs a blocking UDP Socket.
<br><br>

</dd>
<dt><div class="d_decl">this();
</div></dt>
<dd>Constructs a blocking UDP Socket.
<br><br>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
 
</div>


<div id="copyright">
Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

