<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.boxer - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        newText += '<a href="#' + a.name + '"><span class="d_psymbol">'
                + a.name + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="../dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>


	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Phobos/StdBoxer" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="../index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:45:40 2008
</div>
</div>



<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std_bitarray.html" title="Arrays of bits">std.bitarray</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_iterator.html" title="Defines iterators and ranges">std.iterator</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_openrj.html" title="Basic database">std.openrj</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_regexp.html" title="regular expressions">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
</div>

</div>
<div id="content">
    <h1>std.boxer</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\boxer.d -->
This module is a set of types and functions for converting any object (value
 or heap) into a generic box type, allowing the user to pass that object
 around without knowing what's in the box, and then allowing him to recover
 the value afterwards.
<br><br>
<b>WARNING:</b><br>
This module is being phased out. You may want to use <a href="std_variant.html">std.variant</a> for new code.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Convert the integer 45 into a box.
</span>Box b = box(45);

<span class="d_comment">// Recover the integer and cast it to real.
</span><span class="d_keyword">real</span> r = unbox!(<span class="d_keyword">real</span>)(b);
</pre>

 That is the basic interface and will usually be all that you need to
 understand. If it cannot unbox the object to the given type, it throws
 UnboxException. As demonstrated, it uses implicit casts to behave in the exact
 same way that static types behave. So for example, you can unbox from int to
 real, but you cannot unbox from real to int: that would require an explicit
 cast.
<br><br>

 This therefore means that attempting to unbox an int as a string will throw
 an error instead of formatting it. In general, you can call the toString method
 on the box and receive a good result, depending upon whether std.string.format
 accepts it.
<br><br>

 Boxes can be compared to one another and they can be used as keys for
 associative arrays.
<br><br>

 There are also functions for converting to and from arrays of boxes.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Convert arguments into an array of boxes.
</span>Box[] a = boxArray(1, 45.4, <span class="d_string">"foobar"</span>);

<span class="d_comment">// Convert an array of boxes back into arguments.
</span>TypeInfo[] arg_types;
<span class="d_keyword">void</span>* arg_data;

boxArrayToArguments(a, arg_types, arg_data);

<span class="d_comment">// Convert the arguments back into boxes using a
</span><span class="d_comment">// different form of the function.
</span>a = boxArray(arg_types, arg_data);
</pre>
 One use of this is to support a variadic function more easily and robustly;
 simply call "boxArray(arguments, argptr)", then do whatever you need to do
 with the array.

<br><br>
<b>Authors:</b><br>
Burton Radons
<br><br>
<b>License:</b><br>
Public Domain
<br><br>

<dl><dt><div class="d_decl">enum <a name="TypeClass"></a><u>TypeClass</u>;
</div></dt>
<dd>The type class returned from Box.findTypeClass; the order of entries is important. 
<br><br>

<dl><dt><div class="d_decl"><a name="Bool"></a><u>Bool</u></div></dt>
<dd>&lt; bool 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Integer"></a><u>Integer</u></div></dt>
<dd>&lt; byte, ubyte, short, ushort, int, uint, long, ulong 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Float"></a><u>Float</u></div></dt>
<dd>&lt; float, double, real 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Complex"></a><u>Complex</u></div></dt>
<dd>&lt; cfloat, cdouble, creal 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Imaginary"></a><u>Imaginary</u></div></dt>
<dd>&lt; ifloat, idouble, ireal 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Class"></a><u>Class</u></div></dt>
<dd>&lt; Inherits from Object 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Pointer"></a><u>Pointer</u></div></dt>
<dd>&lt; <a name="Pointer"></a><u>Pointer</u> type (T *) 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Array"></a><u>Array</u></div></dt>
<dd>&lt; <a name="Array"></a><u>Array</u> type (T []) 
<br><br>

</dd>
<dt><div class="d_decl"><a name="Other"></a><u>Other</u></div></dt>
<dd>&lt; Any other type, such as delegates, function pointers, struct, void... 
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="Box"></a><u>Box</u>;
</div></dt>
<dd><a name="Box"></a><u>Box</u> is a generic container for objects (both value and heap), allowing the
 user to box them in a generic form and recover them later.
 A box object contains a value in a generic fashion, allowing it to be
 passed from one place to another without having to know its type.  It is
 created by calling the box function, and you can recover the value by
 instantiating the unbox template.
 
<br><br>

<dl><dt><div class="d_decl">bool <a name="unboxable"></a><u>unboxable</u>(TypeInfo <i>test</i>);
</div></dt>
<dd>Return whether this value could be unboxed as the given type without throwing. 
<br><br>

</dd>
<dt><div class="d_decl">TypeInfo <a name="type"></a><u>type</u>();
</div></dt>
<dd>Property for the <a name="type"></a><u>type</u> contained by the box.
 This is initially <b>null</b> and cannot be assigned directly.
<br><br>
<b>Returns:</b><br>
the <a name="type"></a><u>type</u> of the contained object.
     
<br><br>

</dd>
<dt><div class="d_decl">const(void)[] <a name="data"></a><u>data</u>();
</div></dt>
<dd>Property for the <a name="data"></a><u>data</u> pointer to the value of the box.
 This is initially <b>null</b> and cannot be assigned directly.
<br><br>
<b>Returns:</b><br>
the <a name="data"></a><u>data</u> array.
     
<br><br>

</dd>
<dt><div class="d_decl">string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Attempt to convert the boxed value into a string using std.string.format;
 this will throw if that function cannot handle it. If the box is
 uninitialized then this returns "".
     
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="opEquals"></a><u>opEquals</u>(Box <i>other</i>);
</div></dt>
<dd>Compare this box's value with another box. This implicitly casts if the
 types are different, identical to the regular type system.
     
<br><br>

</dd>
<dt><div class="d_decl">float <a name="opCmp"></a><u>opCmp</u>(Box <i>other</i>);
</div></dt>
<dd>Compare this box's value with another box. This implicitly casts if the
 types are different, identical to the regular type system.
     
<br><br>

</dd>
<dt><div class="d_decl">hash_t <a name="toHash"></a><u>toHash</u>();
</div></dt>
<dd>Return the value's hash.
     
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">Box <a name="box"></a><u>box</u>(...);
</div></dt>
<dd>Box the single argument passed to the function. If more or fewer than one
 argument is passed, this will assert.
 
<br><br>

</dd>
<dt><div class="d_decl">Box <a name="box"></a><u>box</u>(TypeInfo <i>type</i>, void* <i>data</i>);
</div></dt>
<dd>Box the explicitly-defined object. <i>type</i> must not be <b>null</b>; <i>data</i> must not be
 <b>null</b> if the <i>type</i>'s size is greater than zero.
 The <i>data</i> is copied.
 
<br><br>

</dd>
<dt><div class="d_decl">Box[] <a name="boxArray"></a><u>boxArray</u>(TypeInfo[] <i>types</i>, void* <i>data</i>);
</div></dt>
<dd>Convert a list of arguments into a list of boxes.
 
<br><br>

</dd>
<dt><div class="d_decl">Box[] <a name="boxArray"></a><u>boxArray</u>(...);
</div></dt>
<dd>Box each argument passed to the function, returning an array of boxes.
 
<br><br>

</dd>
<dt><div class="d_decl">void <a name="boxArrayToArguments"></a><u>boxArrayToArguments</u>(Box[] <i>arguments</i>, out TypeInfo[] <i>types</i>, out void* <i>data</i>);
</div></dt>
<dd>Convert an array of boxes into an array of <i>arguments</i>.
 
<br><br>

</dd>
<dt><div class="d_decl">class <a name="UnboxException"></a><u>UnboxException</u>: object.Exception;
</div></dt>
<dd>This class is thrown if unbox is unable to cast the value into the desired
 result.
 
<br><br>

<dl><dt><div class="d_decl">Box <a name="object"></a><u>object</u>;
</div></dt>
<dd>This is the box that the user attempted to unbox.
<br><br>

</dd>
<dt><div class="d_decl">TypeInfo <a name="outputType"></a><u>outputType</u>;
</div></dt>
<dd>This is the type that the user attempted to unbox the value as.
<br><br>

</dd>
<dt><div class="d_decl">this(Box <i>object</i>, TypeInfo <i>outputType</i>);
</div></dt>
<dd>Assign parameters and create the message in the form
 <tt>"Could not unbox from type ... to ... ."</tt>
     
<br><br>

</dd>
</dl>
</dd>
<dt><div class="d_decl">T <a name="unboxCastReal"></a><u>unboxCastReal</u>(T)(Box <i>value</i>);
</div></dt>
<dd>A generic unboxer for the real numeric types. 
<br><br>

</dd>
<dt><div class="d_decl">T <a name="unboxCastInteger"></a><u>unboxCastInteger</u>(T)(Box <i>value</i>);
</div></dt>
<dd>A generic unboxer for the integral numeric types. 
<br><br>

</dd>
<dt><div class="d_decl">T <a name="unboxCastComplex"></a><u>unboxCastComplex</u>(T)(Box <i>value</i>);
</div></dt>
<dd>A generic unboxer for the complex numeric types. 
<br><br>

</dd>
<dt><div class="d_decl">T <a name="unboxCastImaginary"></a><u>unboxCastImaginary</u>(T)(Box <i>value</i>);
</div></dt>
<dd>A generic unboxer for the imaginary numeric types. 
<br><br>

</dd>
<dt><div class="d_decl">T <a name="unbox"></a><u>unbox</u>(T)(Box <i>value</i>);
</div></dt>
<dd>The <a name="unbox"></a><u>unbox</u> template takes a type parameter and returns a function that
 takes a box object and returns the specified type.
<br><br>
To use it, instantiate the template with the desired result type, and then
 call the function with the box to convert.
 This will implicitly cast base types as necessary and in a way consistent
 with static types - for example, it will cast a boxed byte into int, but it
 won't cast a boxed float into short.

<br><br>
<b>Throws:</b><br>
UnboxException if it cannot cast

<br><br>
<b>Example:</b><br>
<pre class="d_code"> Box b = box(4.5);
 bit u = unboxable!(<span class="d_keyword">real</span>)(b); <span class="d_comment">// This is true.
</span> <span class="d_keyword">real</span> r = <span class="d_psymbol">unbox</span>!(<span class="d_keyword">real</span>)(b);

 Box y = box(4);
 <span class="d_keyword">int</span> x = <span class="d_psymbol">unbox</span>!(<span class="d_keyword">int</span>) (y);
</pre>
 
<br><br>

</dd>
<dt><div class="d_decl">bool <a name="unboxable"></a><u>unboxable</u>(T)(Box <i>value</i>);
</div></dt>
<dd>Return whether the value can be unboxed as the given type; if this returns
 <b>false</b>, attempting to do so will throw UnboxException.
 
<br><br>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
 
</div>


<div id="copyright">
Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

