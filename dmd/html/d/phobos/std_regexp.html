<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.regexp - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        newText += '<a href="#' + a.name + '"><span class="d_psymbol">'
                + a.name + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="../dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>


	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/StdRegexp" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="../index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:45:44 2008
</div>
</div>



<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std_bitarray.html" title="Arrays of bits">std.bitarray</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_iterator.html" title="Defines iterators and ranges">std.iterator</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_openrj.html" title="Basic database">std.openrj</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_regexp.html" title="regular expressions">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
</div>

</div>
<div id="content">
    <h1>std.regexp</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\regexp.d -->
<a href="http://www.digitalmars.com/ctg/regular.html">Regular
 expressions</a> are a powerful method of string pattern matching.  The
 regular expression language used in this library is the same as
 that commonly used, however, some of the very advanced forms may
 behave slightly differently. The standard observed is the <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"> ECMA standard</a> for regular expressions.
<br><br>
std.<a name="regexp"></a><u>regexp</u> is designed to work only with valid UTF strings as input.
 To validate untrusted input, use std.utf.validate().
<br><br>

 In the following guide, <i>pattern</i>[] refers to a
 <a href="http://www.digitalmars.com/ctg/regular.html">regular expression</a>.
 The <i>attributes</i>[] refers to
	a string controlling the interpretation
	of the regular expression.
	It consists of a sequence of one or more
	of the following characters:
<br><br>

	<table border=1 cellspacing=0 cellpadding=5>
	<caption>Attribute Characters</caption>
	<tr><th>Attribute</th> <th>Action</th></tr>
	<tr>
	<td><b>g</b></td>
	<td>global; repeat over the whole input string</td>
	</tr>
	<tr>
	<td><b>i</b></td>
	<td>case insensitive</td>
	</tr>
	<tr>
	<td><b>m</b></td>
	<td>treat as multiple lines separated by newlines</td>
	</tr>
	</table>
<br><br>

 The <i>format</i>[] string has the formatting characters:
<br><br>

	<table border=1 cellspacing=0 cellpadding=5>
	<caption>Formatting Characters</caption>
	<tr><th>Format</th> <th>Replaced With</th></tr>
	<tr><td><b>$$</b></td>	<td>$</td>
	</tr>
	<tr><td><b>$&amp;</b></td>	<td>The matched substring.</td>
	</tr>
	<tr><td><b>$`</b></td>	<td>The portion of string that precedes the matched substring.</td>
	</tr>
	<tr><td><b>$'</b></td>	<td>The portion of string that follows the matched substring.</td>
	</tr>
	<tr><td><b>$</b><i>n</i></td> <td>The <i>n</i>th capture, where <i>n</i>
			is a single digit 1-9
			and <i>n</i> is not followed by a decimal digit.</td>
	</tr>
	<tr><td><b>$</b><i>nn</i></td> <td>The <i>nn</i>th capture, where <i>nn</i>
			is a two-digit decimal
			number 01-99.
			If <i>nn</i>th capture is undefined or more than the number
			of parenthesized subexpressions, use the empty
			string instead.</td>
	</tr>
	</table>
<br><br>

	Any other $ are left as is.

<br><br>
<b>References:</b><br>
<a href="http://en.wikipedia.org/wiki/Regular_expressions">Wikipedia</a>
<br><br>

<dl><dt><div class="d_decl">string <a name="email"></a><u>email</u>;
</div></dt>
<dd>Regular expression to extract an email address.
<br><br>
<b>References:</b><br>
<a href="http://www.regular-expressions.info/email.html">How to Find or Validate an Email Address</a><br>
	<a href="http://tools.ietf.org/html/rfc2822#section-3.4.1">RFC 2822 Internet Message Format</a>
 
<br><br>

</dd>
<dt><div class="d_decl">string <a name="url"></a><u>url</u>;
</div></dt>
<dd>Regular expression to extract a url 
<br><br>

</dd>
<dt><div class="d_decl">class <a name="RegExpException"></a><u>RegExpException</u>: object.Exception;
</div></dt>
<dd>One of these gets thrown on compilation errors
 
<br><br>

<dl></dl>
</dd>
<dt><div class="d_decl">string <a name="sub"></a><u>sub</u>(string <i>s</i>, string <i>pattern</i>, string <i>format</i>, string <i>attributes</i> = null);
</div></dt>
<dd>Search string for matches with regular expression
 <i>pattern</i> with <i>attributes</i>.
 Replace each match with string generated from <i>format</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>s</i></td>
<td>String to search.</td></tr>
<tr><td>invariant(char)[] <i>pattern</i></td>
<td>Regular expression <i>pattern</i>.</td></tr>
<tr><td>invariant(char)[] <i>format</i></td>
<td>Replacement string <i>format</i>.</td></tr>
<tr><td>invariant(char)[] <i>attributes</i></td>
<td>Regular expression <i>attributes</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
the resulting string
<br><br>
<b>Example:</b><br>
Replace the letters 'a' with the letters 'ZZ'.
<pre class="d_code"> <span class="d_param">s</span> = <span class="d_string">"Strap a rocket engine on a chicken."</span>
 <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"a"</span>, <span class="d_string">"ZZ"</span>)        <span class="d_comment">// result: StrZZp a rocket engine on a chicken.
</span> <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"a"</span>, <span class="d_string">"ZZ"</span>, <span class="d_string">"g"</span>)   <span class="d_comment">// result: StrZZp ZZ rocket engine on ZZ chicken.
</span></pre>
	The replacement <i>format</i> can reference the matches using
	the $&amp;, $$, $', $`,  .. 9 notation:
<pre class="d_code"> <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"[ar]"</span>, <span class="d_string">"[$&amp;]"</span>, <span class="d_string">"g"</span>) <span class="d_comment">// result: St[r][a]p [a] [r]ocket engine on [a] chi
</span></pre>
 
<br><br>

</dd>
<dt><div class="d_decl">string <a name="sub"></a><u>sub</u>(string <i>s</i>, string <i>pattern</i>, invariant(char)[] delegate(RegExp) <i>dg</i>, string <i>attributes</i> = null);
</div></dt>
<dd>Search string for matches with regular expression
 <i>pattern</i> with <i>attributes</i>.
 Pass each match to delegate <i>dg</i>.
 Replace each match with the return value from <i>dg</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>s</i></td>
<td>String to search.</td></tr>
<tr><td>invariant(char)[] <i>pattern</i></td>
<td>Regular expression <i>pattern</i>.</td></tr>
<tr><td>invariant(char)[] delegate(RegExp) <i>dg</i></td>
<td>Delegate</td></tr>
<tr><td>invariant(char)[] <i>attributes</i></td>
<td>Regular expression <i>attributes</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
the resulting string.
<br><br>
<b>Example:</b><br>
Capitalize the letters 'a' and 'r':
<pre class="d_code"> <span class="d_param">s</span> = <span class="d_string">"Strap a rocket engine on a chicken."</span>;
 <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"[ar]"</span>,
    <span class="d_keyword">delegate</span> <span class="d_keyword">char</span>[] (RegExp m)
    {
         <span class="d_keyword">return</span> toupper(m[0]);
    },
    <span class="d_string">"g"</span>);    <span class="d_comment">// result: StRAp A Rocket engine on A chicken.
</span></pre>
 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="find"></a><u>find</u>(string <i>s</i>, RegExp <i>pattern</i>);
</div></dt>
<dd>Search <span class="d_param"><i>s</i>[]</span> for first match with <span class="d_param"><i>pattern</i></span>.
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>s</i></td>
<td>String to search.</td></tr>
<tr><td>RegExp <i>pattern</i></td>
<td>Regular expression <i>pattern</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
index into <i>s</i>[] of match if found, -1 if no match.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> <span class="d_param">s</span> = <span class="d_string">"abcabcabab"</span>;
 <span class="d_psymbol">find</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"b"</span>));    <span class="d_comment">// match, returns 1
</span> <span class="d_psymbol">find</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"f"</span>));    <span class="d_comment">// no match, returns -1
</span></pre>
 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="find"></a><u>find</u>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</div></dt>
<dd><b>Returns:</b><br>
Same as <span class="d_param"><a name="find"></a><u>find</u>(<i>s</i>, RegExp(<i>pattern</i>, <i>attributes</i>))</span>.

<br><br>
<b>WARNING:</b><br>
This function is scheduled for deprecation due to unnecessary
ambiguity with the homonym function in std.string. Instead of
<span class="d_param">std.regexp.<a name="find"></a><u>find</u>(<i>s</i>, p, a)</span>, you may want to use <span class="d_param"><a name="find"></a><u>find</u>(<i>s</i>, RegExp(p, a))</span>.
<br><br>

</dd>
<dt><div class="d_decl">int <a name="rfind"></a><u>rfind</u>(string <i>s</i>, RegExp <i>pattern</i>);
</div></dt>
<dd>Search <span class="d_param"><i>s</i>[]</span> for last match with <span class="d_param"><i>pattern</i></span>.
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>s</i></td>
<td>String to search.</td></tr>
<tr><td>RegExp <i>pattern</i></td>
<td>Regular expression <i>pattern</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
index into <i>s</i>[] of match if found, -1 if no match.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> <span class="d_param">s</span> = <span class="d_string">"abcabcabab"</span>;
 <span class="d_psymbol">rfind</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"b"</span>));    <span class="d_comment">// match, returns 9
</span> <span class="d_psymbol">rfind</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"f"</span>));    <span class="d_comment">// no match, returns -1
</span></pre>
 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="rfind"></a><u>rfind</u>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</div></dt>
<dd><b>Returns:</b><br>
Same as <span class="d_param"><a name="rfind"></a><u>rfind</u>(<i>s</i>, RegExp(<i>pattern</i>, <i>attributes</i>))</span>.

<br><br>
<b>WARNING:</b><br>
This function is scheduled for deprecation due to unnecessary
ambiguity with the homonym function in std.string. Instead of
<span class="d_param">std.regexp.<a name="rfind"></a><u>rfind</u>(<i>s</i>, p, a)</span>, you may want to use <span class="d_param"><a name="rfind"></a><u>rfind</u>(<i>s</i>, RegExp(p, a))</span>.
<br><br>

</dd>
<dt><div class="d_decl">invariant(char)[][] <a name="split"></a><u>split</u>(string <i>s</i>, RegExp <i>pattern</i>);
</div></dt>
<dd>Split <i>s</i>[] into an array of strings, using the regular
 expression <span class="d_param"><i>pattern</i></span> as the separator.
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>s</i></td>
<td>String to search.</td></tr>
<tr><td>RegExp <i>pattern</i></td>
<td>Regular expression <i>pattern</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
array of slices into <i>s</i>[]
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">foreach</span> (<span class="d_param">s</span>; <span class="d_psymbol">split</span>(<span class="d_string">"abcabcabab"</span>, RegExp(<span class="d_string">"C."</span>, <span class="d_string">"i"</span>)))
 {
     writefln(<span class="d_string">"s = '%s'"</span>, <span class="d_param">s</span>);
 }
 <span class="d_comment">// Prints:
</span> <span class="d_comment">// s = 'ab'
</span> <span class="d_comment">// s = 'b'
</span> <span class="d_comment">// s = 'bab'
</span></pre>
 
<br><br>

</dd>
<dt><div class="d_decl">invariant(char)[][] <a name="split"></a><u>split</u>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</div></dt>
<dd><b>Returns:</b><br>
Same as <span class="d_param"><a name="split"></a><u>split</u>(<i>s</i>, RegExp(<i>pattern</i>, <i>attributes</i>))</span>.

<br><br>
<b>WARNING:</b><br>
This function is scheduled for deprecation due to unnecessary
ambiguity with the homonym function in std.string. Instead of
<span class="d_param">std.regexp.<a name="split"></a><u>split</u>(<i>s</i>, p, a)</span>, you may want to use <span class="d_param"><a name="split"></a><u>split</u>(<i>s</i>, RegExp(p, a))</span>.
 
<br><br>

</dd>
<dt><div class="d_decl">RegExp <a name="search"></a><u>search</u>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</div></dt>
<dd>Search <i>s</i>[] for first match with <i>pattern</i>[] with <i>attributes</i>[].
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>s</i></td>
<td>String to <a name="search"></a><u>search</u>.</td></tr>
<tr><td>invariant(char)[] <i>pattern</i></td>
<td>Regular expression <i>pattern</i>.</td></tr>
<tr><td>invariant(char)[] <i>attributes</i></td>
<td>Regular expression <i>attributes</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
corresponding RegExp if found, <b>null</b> if not.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">import</span> std.stdio;
 <span class="d_keyword">import</span> std.regexp;

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">if</span> (<span class="d_keyword">auto</span> m = std.regexp.<span class="d_psymbol">search</span>(<span class="d_string">"abcdef"</span>, <span class="d_string">"c"</span>))
     {
         writefln(<span class="d_string">"%s[%s]%s"</span>, m.pre, m[0], m.post);
     }
 }
 <span class="d_comment">// Prints:
</span> <span class="d_comment">// ab[c]def
</span></pre>
 
<br><br>

</dd>
<dt><div class="d_decl">class <a name="RegExp"></a><u>RegExp</u>;
</div></dt>
<dd><a name="RegExp"></a><u>RegExp</u> is a class to handle regular expressions.
<br><br>
It is the core foundation for adding powerful string pattern matching
 capabilities to programs like grep, text editors, awk, sed, etc.
 
<br><br>

<dl><dt><div class="d_decl">this(string <i>pattern</i>, string <i>attributes</i> = null);
</div></dt>
<dd>Construct a RegExp object. Compile <i>pattern</i>
 with <i><i>attributes</i></i> into
 an internal form for fast execution.
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>pattern</i></td>
<td>regular expression</td></tr>
<tr><td>invariant(char)[] <i>attributes</i></td>
<td>attributes</td></tr>
</table><br>
<b>Throws:</b><br>
RegExpException if there are any compilation errors.
<br><br>
<b>Example:</b><br>
Declare two variables and assign to them a RegExp object:
<pre class="d_code"> <span class="d_keyword">auto</span> r = <span class="d_keyword">new</span> RegExp(<span class="d_string">"pattern"</span>);
 <span class="d_keyword">auto</span> s = <span class="d_keyword">new</span> RegExp(<span class="d_string">r"p[1-5]\s*"</span>);
</pre>
     
<br><br>

</dd>
<dt><div class="d_decl">static RegExp <a name="opCall"></a><u>opCall</u>(string <i>pattern</i>, string <i>attributes</i> = null);
</div></dt>
<dd>Generate instance of RegExp.
<br><br>
<b>Params:</b><br>
<table><tr><td>invariant(char)[] <i>pattern</i></td>
<td>regular expression</td></tr>
<tr><td>invariant(char)[] <i>attributes</i></td>
<td>attributes</td></tr>
</table><br>
<b>Throws:</b><br>
RegExpException if there are any compilation errors.
<br><br>
<b>Example:</b><br>
Declare two variables and assign to them a RegExp object:
<pre class="d_code"> <span class="d_keyword">auto</span> r = RegExp(<span class="d_string">"pattern"</span>);
 <span class="d_keyword">auto</span> s = RegExp(<span class="d_string">r"p[1-5]\s*"</span>);
</pre>
     
<br><br>

</dd>
<dt><div class="d_decl">RegExp <a name="search"></a><u>search</u>(<i>string</i> <i>string</i>);
<br>int <a name="opApply"></a><u>opApply</u>(int delegate(ref RegExp) <i>dg</i>);
</div></dt>
<dd>Set up for start of foreach loop.
<br><br>
<b>Returns:</b><br>
<a name="search"></a><u>search</u>() returns instance of RegExp set up to search <i>string</i>[].
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">import</span> std.stdio;
 <span class="d_keyword">import</span> std.regexp;

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">foreach</span>(m; RegExp(<span class="d_string">"ab"</span>).<span class="d_psymbol">search</span>(<span class="d_string">"abcabcabab"</span>))
     {
         writefln(<span class="d_string">"%s[%s]%s"</span>, m.pre, m[0], m.post);
     }
 }
 <span class="d_comment">// Prints:
</span> <span class="d_comment">// [ab]cabcabab
</span> <span class="d_comment">// abc[ab]cabab
</span> <span class="d_comment">// abcabc[ab]ab
</span> <span class="d_comment">// abcabcab[ab]
</span></pre>
     
<br><br>

</dd>
<dt><div class="d_decl">string <a name="opIndex"></a><u>opIndex</u>(size_t <i>n</i>);
</div></dt>
<dd>Retrieve match <i>n</i>.
<br><br>
<i>n</i>==0 means the matched substring, <i>n</i>&gt;0 means the
 <i>n</i>'th parenthesized subexpression.
 if <i>n</i> is larger than the number of parenthesized subexpressions,
 <b>null</b> is returned.
     
<br><br>

</dd>
<dt><div class="d_decl">string <a name="match"></a><u>match</u>(size_t <i>n</i>);
</div></dt>
<dd>Same as <span class="d_param">opIndex(<i>n</i>)</span>.
<br><br>
<b>WARNING:</b><br>
Scheduled for deprecation due to confusion with overloaded
       <span class="d_param"><a name="match"></a><u>match</u>(string)</span>. Instead of <span class="d_param">regex.<a name="match"></a><u>match</u>(<i>n</i>)</span>
       you may want to use <span class="d_param">regex[<i>n</i>]</span>.
    
<br><br>

</dd>
<dt><div class="d_decl">string <a name="pre"></a><u>pre</u>();
</div></dt>
<dd>Return the slice of the input that precedes the matched substring.
     
<br><br>

</dd>
<dt><div class="d_decl">string <a name="post"></a><u>post</u>();
</div></dt>
<dd>Return the slice of the input that follows the matched substring.
     
<br><br>

</dd>
<dt><div class="d_decl">invariant(char)[][] <a name="split"></a><u>split</u>(string <i>s</i>);
</div></dt>
<dd>Split <i>s</i>[] into an array of strings, using the regular
 expression as the separator.
<br><br>
<b>Returns:</b><br>
array of slices into <i>s</i>[]
 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="find"></a><u>find</u>(<i>string</i> <i>string</i>);
</div></dt>
<dd>Search <i>string</i>[] for match with regular expression.
<br><br>
<b>Returns:</b><br>
index of match if successful, -1 if not found
 
<br><br>

</dd>
<dt><div class="d_decl">invariant(char)[][] <a name="match"></a><u>match</u>(string <i>s</i>);
</div></dt>
<dd>Search <i>s</i>[] for <a name="match"></a><u>match</u>.
<br><br>
<b>Returns:</b><br>
If global attribute, return same value as exec(<i>s</i>).
	If not global attribute, return array of all matches.
 
<br><br>

</dd>
<dt><div class="d_decl">string <a name="replace"></a><u>replace</u>(string <i>s</i>, string <i>format</i>);
</div></dt>
<dd>Find regular expression matches in <i>s</i>[]. Replace those matches
 with a new string composed of <i>format</i>[] merged with the result of the
 matches.
 If global, <a name="replace"></a><u>replace</u> all matches. Otherwise, <a name="replace"></a><u>replace</u> first match.
<br><br>
<b>Returns:</b><br>
the new string
 
<br><br>

</dd>
<dt><div class="d_decl">invariant(char)[][] <a name="exec"></a><u>exec</u>(<i>string</i> <i>string</i>);
</div></dt>
<dd>Search <i>string</i>[] for match.
<br><br>
<b>Returns:</b><br>
array of slices into <i>string</i>[] representing matches
 
<br><br>

</dd>
<dt><div class="d_decl">invariant(char)[][] <a name="exec"></a><u>exec</u>();
</div></dt>
<dd>Pick up where last <a name="exec"></a><u>exec</u>(string) or <a name="exec"></a><u>exec</u>() left off,
 searching string[] for next match.
<br><br>
<b>Returns:</b><br>
array of slices into string[] representing matches
 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="test"></a><u>test</u>(string <i>s</i>);
</div></dt>
<dd>Search <i>s</i>[] for match.
<br><br>
<b>Returns:</b><br>
0 for no match, !=0 for match
<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.regexp;
<span class="d_keyword">import</span> std.string;

<span class="d_keyword">int</span> grep(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">char</span>[]) pred, <span class="d_keyword">char</span>[][] list)
{
  <span class="d_keyword">int</span> count;
  <span class="d_keyword">foreach</span> (<span class="d_param">s</span>; list)
  {  <span class="d_keyword">if</span> (pred(<span class="d_param">s</span>))
       ++count;
  }
  <span class="d_keyword">return</span> count;
}

<span class="d_keyword">void</span> main()
{
  <span class="d_keyword">auto</span> x = grep(&amp;RegExp(<span class="d_string">"[Ff]oo"</span>).<span class="d_psymbol">test</span>,
                std.string.split(<span class="d_string">"mary had a foo lamb"</span>));
  writefln(x);
}
</pre>
 which prints: 1
 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="test"></a><u>test</u>();
</div></dt>
<dd>Pick up where last <a name="test"></a><u>test</u>(string) or <a name="test"></a><u>test</u>() left off, and search again.
<br><br>
<b>Returns:</b><br>
0 for no match, !=0 for match
 
<br><br>

</dd>
<dt><div class="d_decl">int <a name="test"></a><u>test</u>(string <i>s</i>, int <i>startindex</i>);
</div></dt>
<dd>Test <i>s</i>[] starting at <i>startindex</i> against regular expression.
<br><br>
<b>Returns:</b><br>
0 for no match, !=0 for match
 
<br><br>

</dd>
<dt><div class="d_decl">alias <a name="opEquals"></a><u>opEquals</u>;
</div></dt>
<dd>Returns whether string <span class="d_param">s</span> matches <span class="d_param">this</span>.
    
<br><br>

</dd>
<dt><div class="d_decl">string <a name="replace"></a><u>replace</u>(string <i>format</i>);
</div></dt>
<dd>After a match is found with test(), this function
 will take the match results and, using the <i>format</i>
 string, generate and return a new string.
 
<br><br>

</dd>
<dt><div class="d_decl">string <a name="replaceOld"></a><u>replaceOld</u>(string <i>format</i>);
</div></dt>
<dd>Like replace(char[] <i>format</i>), but uses old style formatting:
		<table border=1 cellspacing=0 cellpadding=5>
		<th>Format
		<th>Description
		<tr>
		<td><b>&amp;</b>
		<td>replace with the match
		</tr>
		<tr>
		<td><b>\</b><i>n</i>
		<td>replace with the <i>n</i>th parenthesized match, <i>n</i> is 1..9
		</tr>
		<tr>
		<td><b>\</b><i>c</i>
		<td>replace with char <i>c</i>.
		</tr>
		</table>
 
<br><br>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
 
</div>


<div id="copyright">
Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

