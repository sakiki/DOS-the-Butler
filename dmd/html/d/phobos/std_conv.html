<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.conv - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        newText += '<a href="#' + a.name + '"><span class="d_psymbol">'
                + a.name + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="../dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>


	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Phobos/StdConv" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="../index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:45:41 2008
</div>
</div>



<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std_bitarray.html" title="Arrays of bits">std.bitarray</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_iterator.html" title="Defines iterators and ranges">std.iterator</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_openrj.html" title="Basic database">std.openrj</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_regexp.html" title="regular expressions">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
</div>

</div>
<div id="content">
    <h1>std.conv</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\conv.d -->
A one-stop shop for converting values from one type to another.
<br><br>
<b>Authors:</b><br>
<a href="http://digitalmars.com">Walter Bright</a>, <a href="http://erdani.org">Andrei
Alexandrescu</a>
<br><br>

<dl><dt><div class="d_decl">class <a name="ConvError"></a><u>ConvError</u>: object.Error;
</div></dt>
<dd>Thrown on conversion errors.
 
<br><br>

<dl></dl>
</dd>
<dt><div class="d_decl">class <a name="ConvOverflowError"></a><u>ConvOverflowError</u>: object.Error;
</div></dt>
<dd>Thrown on conversion overflow errors.
 
<br><br>

<dl></dl>
</dd>
<dt><div class="d_decl">Target <a name="to"></a><u>to</u>(Target,Source)(Source <i>value</i>);
</div></dt>
<dd>The <span class="d_param"><a name="to"></a><u>to</u></span> family of functions converts a value from type
<span class="d_param">Source</span> <a name="to"></a><u>to</u> type <span class="d_param">Target</span>. The source type is
deduced and the target type must be specified, for example the
expression <span class="d_param"><a name="to"></a><u>to</u>!(int)(42.0)</span> converts the number 42 from
<span class="d_param">double</span> <a name="to"></a><u>to</u> <span class="d_param">int</span>. The conversion is "safe", i.e.,
it checks for overflow; <span class="d_param"><a name="to"></a><u>to</u>!(int)(4.2e10)</span> would throw the
<span class="d_param">ConvOverflowError</span> exception. Overflow checks are only
inserted when necessary, e.g., <span class="d_param"><a name="to"></a><u>to</u>!(double)(42)</span> does not do
any checking because any int fits in a double.
<br><br>
Converting a value <a name="to"></a><u>to</u> its own type (useful mostly for generic code)
simply returns its argument.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span> a = 42;
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!(<span class="d_keyword">int</span>)(a); <span class="d_comment">// b is int with value 42
</span><span class="d_keyword">auto</span> c = <span class="d_psymbol">to</span>!(<span class="d_keyword">double</span>)(3.14); <span class="d_comment">// c is double with value 3.14
</span></pre>
Converting among numeric types is a safe way <a name="to"></a><u>to</u> cast them around.
Conversions from floating-point types <a name="to"></a><u>to</u> integral types allow loss of
precision (the fractional part of a floating-point number). The
conversion is truncating towards zero, the same way a cast would
truncate. (To round a floating point value when casting <a name="to"></a><u>to</u> an
integral, use <span class="d_param">roundTo</span>.)
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><span class="d_keyword">int</span> a = 420;
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!(<span class="d_keyword">long</span>)(a); <span class="d_comment">// same as long b = a;
</span><span class="d_keyword">auto</span> c = <span class="d_psymbol">to</span>!(<span class="d_keyword">byte</span>)(a / 10); <span class="d_comment">// fine, c = 42
</span><span class="d_keyword">auto</span> d = <span class="d_psymbol">to</span>!(<span class="d_keyword">byte</span>)(a); <span class="d_comment">// throw ConvOverflowError
</span><span class="d_keyword">double</span> e = 4.2e6;
<span class="d_keyword">auto</span> f = <span class="d_psymbol">to</span>!(<span class="d_keyword">int</span>)(e); <span class="d_comment">// f == 4200000
</span>e = -3.14;
<span class="d_keyword">auto</span> g = <span class="d_psymbol">to</span>!(<span class="d_keyword">uint</span>)(e); <span class="d_comment">// fails: floating-to-integral underflow
</span>e = 3.14;
<span class="d_keyword">auto</span> h = <span class="d_psymbol">to</span>!(<span class="d_keyword">uint</span>)(e); <span class="d_comment">// h = 3
</span>e = 3.99;
h = <span class="d_psymbol">to</span>!(<span class="d_keyword">uint</span>)(a); <span class="d_comment">// h = 3
</span>e = -3.99;
f = <span class="d_psymbol">to</span>!(<span class="d_keyword">int</span>)(a); <span class="d_comment">// f = -3
</span></pre>

Conversions from integral types <a name="to"></a><u>to</u> floating-point types always
succeed, but might lose accuracy. The largest integers with a
predecessor representable in floating-point format are 2^24-1 for
float, 2^53-1 for double, and 2^64-1 for <span class="d_param">real</span> (when
<span class="d_param">real</span> is 80-bit, e.g. on Intel machines).

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span> a = 16_777_215; <span class="d_comment">// 2^24 - 1, largest proper integer representable as float
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">to</span>!(<span class="d_keyword">int</span>)(<span class="d_psymbol">to</span>!(<span class="d_keyword">float</span>)(a)) == a);
<span class="d_keyword">assert</span>(<span class="d_psymbol">to</span>!(<span class="d_keyword">int</span>)(<span class="d_psymbol">to</span>!(<span class="d_keyword">float</span>)(-a)) == -a);
a += 2;
<span class="d_keyword">assert</span>(<span class="d_psymbol">to</span>!(<span class="d_keyword">int</span>)(<span class="d_psymbol">to</span>!(<span class="d_keyword">float</span>)(a)) == a); <span class="d_comment">// fails!
</span></pre>

Conversions from string <a name="to"></a><u>to</u> numeric types differ from the C equivalents
<span class="d_param">atoi()</span> and <span class="d_param">atol()</span> by checking for overflow and
not allowing whitespace.
<br><br>

For conversion of strings <a name="to"></a><u>to</u> signed types, the grammar recognized is:
<pre>
<i>Integer</i>: <i>Sign UnsignedInteger</i>
<i>UnsignedInteger</i>
<i>Sign</i>:
    <b>+</b>
    <b>-</b>
</pre>
For conversion <a name="to"></a><u>to</u> unsigned types, the grammar recognized is:
<pre>
<i>UnsignedInteger</i>:
    <i>DecimalDigit</i>
    <i>DecimalDigit</i> <i>UnsignedInteger</i>
</pre>
<br><br>

Converting an array <a name="to"></a><u>to</u> another array type works by converting each
element in turn. Associative arrays can be converted <a name="to"></a><u>to</u> associative
arrays as long as keys and values can in turn be converted.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = ([1, 2, 3]).dup;
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!(<span class="d_keyword">float</span>[])(a);
<span class="d_keyword">assert</span>(b == [1.0f, 2, 3]);
string str = <span class="d_string">"1 2 3 4 5 6"</span>;
<span class="d_keyword">auto</span> numbers = <span class="d_psymbol">to</span>!(<span class="d_keyword">double</span>[])(split(str));
<span class="d_keyword">assert</span>(numbers == [1.0, 2, 3, 4, 5, 6]);
<span class="d_keyword">int</span>[string] c;
c[<span class="d_string">"a"</span>] = 1;
c[<span class="d_string">"b"</span>] = 2;
<span class="d_keyword">auto</span> d = <span class="d_psymbol">to</span>!(<span class="d_keyword">double</span>[wstring])(c);
<span class="d_keyword">assert</span>(d[<span class="d_string">"a"w</span>] == 1 &amp;&amp; d[<span class="d_string">"b"w</span>] == 2);
</pre>

Conversions operate transitively, meaning that they work on arrays and
associative arrays of any complexity:
<br><br>

<pre class="d_code"><span class="d_keyword">int</span>[string][<span class="d_keyword">double</span>[<span class="d_keyword">int</span>[]]] a;
...
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!(<span class="d_keyword">short</span>[wstring][string[<span class="d_keyword">double</span>[]]])(a);
</pre>

This conversion works because <span class="d_param"><a name="to"></a><u>to</u>!(short)</span> applies <a name="to"></a><u>to</u> an
<span class="d_param">int</span>, <span class="d_param"><a name="to"></a><u>to</u>!(wstring)</span> applies <a name="to"></a><u>to</u> a <span class="d_param">string</span>, <span class="d_param"><a name="to"></a><u>to</u>!(string)</span> applies <a name="to"></a><u>to</u> a <span class="d_param">double</span>, and
<span class="d_param"><a name="to"></a><u>to</u>!(double[])</span> applies <a name="to"></a><u>to</u> an <span class="d_param">int[]</span>. The
conversion might throw an exception because <span class="d_param"><a name="to"></a><u>to</u>!(short)</span>
might fail the range check.

<br><br>

</dd>
<dt><div class="d_decl">template <a name="roundTo"></a><u>roundTo</u>(Target)</div></dt>
<dd>Rounded conversion from floating point to integral.
<br><br>
<b>Example:</b><br>
<pre class="d_code">  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(3.14) == 3);
  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(3.49) == 3);
  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(3.5) == 4);
  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(3.999) == 4);
  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(-3.14) == -3);
  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(-3.49) == -3);
  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(-3.5) == -4);
  <span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">int</span>)(-3.999) == -4);
</pre>
Rounded conversions do not work with non-integral target types.
 
<br><br>

<dl></dl>
</dd>
<dt><div class="d_decl">template <a name="parse"></a><u>parse</u>(Target)</div></dt>
<dd>The <span class="d_param"><a name="parse"></a><u>parse</u></span> family of functions works quite like the
 <span class="d_param">to</span> family, except that (1) it only works with strings as
 input, (2) takes the input string by reference and advances it to
 the position following the conversion, and (3) does not throw if it
 could not convert the entire string. It still throws if an overflow
 occurred during conversion or if no character of the input string
 was meaningfully converted.
<br><br>
<b>Example:</b><br>
<pre class="d_code">string test = <span class="d_string">"123 \t  76.14"</span>;
<span class="d_keyword">auto</span> a = <span class="d_psymbol">parse</span>!(<span class="d_keyword">uint</span>)(test);
<span class="d_keyword">assert</span>(a == 123);
<span class="d_keyword">assert</span>(test == <span class="d_string">" \t  76.14"</span>); <span class="d_comment">// parse bumps string
</span>munch(test, <span class="d_string">" \t\n\r"</span>); <span class="d_comment">// skip ws
</span><span class="d_keyword">assert</span>(test == <span class="d_string">"76.14"</span>);
<span class="d_keyword">auto</span> b = <span class="d_psymbol">parse</span>!(<span class="d_keyword">double</span>)(test);
<span class="d_keyword">assert</span>(b == 76.14);
<span class="d_keyword">assert</span>(test == <span class="d_string">""</span>);
</pre>
 
<br><br>

<dl></dl>
</dd>
<dt><div class="d_decl">int <a name="toInt"></a><u>toInt</u>(string <i>s</i>);
<br>uint <a name="toUint"></a><u>toUint</u>(string <i>s</i>);
<br>long <a name="toLong"></a><u>toLong</u>(string <i>s</i>);
<br>ulong <a name="toUlong"></a><u>toUlong</u>(string <i>s</i>);
<br>short <a name="toShort"></a><u>toShort</u>(string <i>s</i>);
<br>ushort <a name="toUshort"></a><u>toUshort</u>(string <i>s</i>);
<br>byte <a name="toByte"></a><u>toByte</u>(string <i>s</i>);
<br>ubyte <a name="toUbyte"></a><u>toUbyte</u>(string <i>s</i>);
<br>float <a name="toFloat"></a><u>toFloat</u>(Char)(Char[] <i>s</i>);
<br>double <a name="toDouble"></a><u>toDouble</u>(Char)(Char[] <i>s</i>);
<br>real <a name="toReal"></a><u>toReal</u>(Char)(Char[] <i>s</i>);
</div></dt>
<dd>Convert character string to the return type. These functions will be
 deprecated because <span class="d_param">to!(T)</span> supersedes them.
 
<br><br>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
 
</div>


<div id="copyright">
Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

