
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Memory Management - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.gif" width="270" height="53" style="border-style:none" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>
	<br>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Memory
" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/d/download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:44:01 2008
</div>
</div>

<!-- Generated by Ddoc from memory.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D &rarr;</a></li>
	<li><a href="lex.html" title="D Language Specification">Language &rarr;</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos &rarr;</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons &rarr;</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D 1.0 &rarr;</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
	<ul>		<li><a href="overview.html" title="D language overview">Overview</a></li>

		<li><a href="windows.html" title="D implementation for 32 bit Windows systems">D for Win32</a></li>

		<li><a href="dll.html" title="Writing 32 bit Windows DLLs in D">Win32 DLLs in D</a></li>

		<li><a href="COM.html" title="Windows COM Programming">COM Programming</a></li>

		<li><a href="htomodule.html" title="converting C .h header files to D modules">C .h to D Modules</a></li>

		<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>

		<li><a href="dstyle.html" title="Recommended programming style conventions">Style Guide</a></li>

		<li><a href="wc.html" title="wc - the wordcount program">Example: wc</a></li>

		<li><a href="future.html" title="Future directions">Future</a></li>

		<li><a href="changelog.html" title="History of changes to D">D Change Log</a></li>

		<li><a href="features2.html" title="Language changes for D 2.0">2.0 Features</a></li>

		<li><a href="http://www.digitalmars.com/techtips/index.html" title="Programming tips">Tech Tips</a></li>

		<li><a href="rationale.html" title="Answers to questions about D design decisions">Rationale</a></li>

		<li><a href="warnings.html" title="Explanation of D compiler generated warning messages">Warnings</a></li>

		<li><a href="http://d.puremagic.com/issues/" title="D issue and bug tracking system">Issues &amp; Bugs</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Articles</h2>
	<ul>		<li><a href="hijack.html" title="Function Hijacking Mitigation">Hijacking</a></li>

		<li><a href="const.html" title="Here a Const There a Const">Const</a></li>

		<li><a href="memory.html" title="Memory management techniques in D">Memory Management</a></li>

		<li><a href="exception-safe.html" title="Exception safe programming techniques">Exception Safety</a></li>

		<li><a href="templates-revisited.html" title="D takes a fresh look at template design">Templates Revisited</a></li>

		<li><a href="regular-expression.html" title="Programming with regular expressions">Regular Expressions</a></li>

		<li><a href="lazy-evaluation.html" title="Lazy evaluation of function arguments">Lazy Evaluation</a></li>

		<li><a href="variadic-function-templates.html" title="Variadic arguments to templates">Variadic Templates</a></li>

		<li><a href="tuple.html" title="What tuples are and how to use them">Tuples</a></li>

		<li><a href="mixin.html" title="String mixins compile string literals into D programs">Mixins</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Tools</h2>
	<ul>		<li><a href="dcompiler.html" title="dmd - the Digital Mars D compiler">DMD D Compiler</a></li>

		<li><a href="http://dgcc.sourceforge.net/" title="gdc - the Gnu D compiler">GDC D Compiler</a></li>

		<li><a href="http://www.digitalmars.com/ctg/optlink.html" title="Optlink - the Digital Mars Linker">Linker</a></li>

		<li><a href="http://www.digitalmars.com/ctg/trace.html" title="DMD's builtin code profiling tool">Profiler</a></li>

		<li><a href="code_coverage.html" title="DMD's builtin code coverage analysis tool">Code Coverage</a></li>

		<li><a href="rdmd.html" title="rdmd - run D programs as if they were scripts">DMD Script Shell</a></li>

		<li><a href="windbg.html" title="windbg - debugging Windows programs">Windows Debugger</a></li>

		<li><a href="htod.html" title="htod - mechanically convert C .h header files to D">C .h to D .d</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?EditorSupport" title="Editors with support for D">Editors</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?ReferenceForTools" title="Even more tools for D">More Tools</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Community</h2>
	<ul>		<li><a href="http://d.puremagic.com/conference2007/" title="D Programming Language Conference">D Conference</a></li>

		
		<li><a href="http://www.digitalmars.com/NewsGroup.html" title="How to connect to D newsgroups">News</a></li>

		<li><a href="http://www.digitalmars.com/webnews/newsgroups.php?search_txt=&group=digitalmars.D
" title="Forum for general D topics">D forum</a></li>

		<li><a href="http://www.digitalmars.com/webnews/newsgroups.php?search_txt=&group=digitalmars.D.announce
" title="Forum for D announcements">Announcements</a></li>

		<li><a href="http://www.digitalmars.com/webnews/newsgroups.php?search_txt=&group=digitalmars.D.learn
" title="Forum for learning D">Learn</a></li>

		<li><a href="http://www.digitalmars.com/webnews/newsgroups.php?search_txt=&group=digitalmars.D.debugger
" title="Forum for D debuggers">Debugging</a></li>

		<li><a href="http://www.digitalmars.com/d/dlinks.html" title="External D related links">D links</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Archives</h2>
	<ul>		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/index.html">digitalmars.D</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dtl/index.html">digitalmars.D.dtl</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/announce/index.html">digitalmars.D.announce</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dwt/index.html">digitalmars.D.dwt</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/learn/index.html">digitalmars.D.learn</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/bugs/index.html">digitalmars.D.bugs</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/debugger/index.html">digitalmars.D.debugger</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/D/gnu/index.html">D.gnu</a></li>
		<li><a href="http://www.digitalmars.com/d/archives/index.html">Old D</a></li>
	</ul>
    </div>

    <div class="navblock">
	<h2>Appendices</h2>
	<ul>		<li><a href="glossary.html" title="D acronyms and jargon explained">Glossary</a></li>

		<li><a href="ascii-table.html" title="Handy ascii chart">Ascii Table</a></li>

		<li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgements</a></li>

	</ul>
    </div>

    
<form action="http://www.google.com/translate" onsubmit="this.u.value=window.location.href" method="GET">
<input value="en" name="hl" type="hidden"/>
<input value="UTF8" name="ie" type="hidden"/>
<input value="" name="u" type="hidden"/>
<select name="langpair">
<option value="en|de"/>German
<option value="en|fr"/>French
<option value="en|it"/>Italian
<option value="en|pt"/>Portuguese
<option value="en|es"/>Spanish
<option value="en|ar"/>Arabic
<option value="en|zh-CN"/>Chinese (Simplified)
<option value="en|ja"/>Japanese
<option value="en|ko"/>Korean
<option value="en|ru"/>Russian
</select><br/>
<input value="Translate" type="submit"/>
</form>


    
<br><br>
<br><br>
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/* 180x150, created 2/18/08 */
/**/google_ad_slot = "4228873179";
/**/google_ad_width = 180;
/**/google_ad_height = 150;
/**/google_cpa_choice = ""; // on file
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>



</div>
<div id="content">
  <h1>        Memory Management</h1>
  
	<p>Any non-trivial program needs to allocate and free memory.
	Memory management techniques become more and more important as
	programs increase in complexity, size, and performance.
	D offers many options for managing memory.
	</p>

	<p>The three primary methods for allocating memory in D are:</p>

	<ol>	<li>Static data, allocated in the default data segment.</li>
	<li>Stack data, allocated on the CPU program stack.</li>
	<li><a href="garbage.html">Garbage collected data</a>,
	allocated dynamically on the
	garbage collection heap.</li>
	</ol>

	<p>The techniques for using them, as well
	as some advanced alternatives are:
	</p>

	<ul>	<li><a href="#copy-on-write">Strings (and Array) Copy-on-Write</a></li>
	<li><a href="#realtime">Real Time</a></li>
	<li><a href="#smoothoperation">Smooth Operation</a></li>
	<li><a href="#freelists">Free Lists</a></li>
	<li><a href="#referencecounting">Reference Counting</a></li>
	<li><a href="#newdelete">Explicit Class Instance Allocation</a></li>
	<li><a href="#markrelease">Mark/Release</a></li>
	<li><a href="#raii">RAII (Resource Acquisition Is Initialization)</a></li>
	<li><a href="#stackclass">Allocating Class Instances On The Stack</a></li>
	<li><a href="#uninitializedarrays">Allocating Uninitialized Arrays On The Stack</a></li>
	<li><a href="#isr">Interrupt Service Routines</a></li>
	</ul>

<h2><a name="copy-on-write">Strings (and Array) Copy-on-Write</a></h2>

	<p>Consider the case of passing an array to a function, possibly
	modifying the contents of the array, and returning the modified
	array. Since arrays are passed by reference, not by value,
	a crucial issue is who owns the contents of the array?
	For example, a function to convert an array of characters to
	upper case:
	</p>

<pre class="d_code"><span class="d_keyword">char</span>[] toupper(<span class="d_keyword">char</span>[] s)
{
    <span class="d_keyword">int</span> i;

    <span class="d_keyword">for</span> (i = 0; i &lt; s.length; i++)
    {
	<span class="d_keyword">char</span> c = s[i];
	<span class="d_keyword">if</span> ('a' &lt;= c &amp;&amp; c &lt;= 'z')
	    s[i] = c - (<span class="d_keyword">cast</span>(<span class="d_keyword">char</span>)'a' - 'A');
    }
    <span class="d_keyword">return</span> s;
}
</pre>

	<p>Note that the caller's version of s[] is also modified. This may
	be not at all what was intended, or worse, s[] may be a slice
	into a read-only section of memory.
	</p>

	<p>If a copy of s[] was always made by toupper(), then that will
	unnecessarily consume time and memory for strings that are already
	all upper case.
	</p>

	<p>The solution is to implement copy-on-write, which means that a copy
	is made only if the string needs to be modified. Some string
	processing languages do do this as the default behavior, but there
	is a huge cost to it. The string "abcdeF" will wind up being copied 5
	times by the function. To get the maximum efficiency using the protocol,
	it'll have to be done explicitly in the code. Here's toupper()
	rewritten to implement copy-on-write in an efficient manner:
	</p>

<pre class="d_code"><span class="d_keyword">char</span>[] toupper(<span class="d_keyword">char</span>[] s)
{
    <span class="d_keyword">int</span> changed;
    <span class="d_keyword">int</span> i;

    changed = 0;
    <span class="d_keyword">for</span> (i = 0; i &lt; s.length; i++)
    {
	<span class="d_keyword">char</span> c = s[i];
	<span class="d_keyword">if</span> ('a' &lt;= c &amp;&amp; c &lt;= 'z')
	{
	    <span class="d_keyword">if</span> (!changed)
	    {   <span class="d_keyword">char</span>[] r = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[s.length];
		r[] = s;
		s = r;
		changed = 1;
	    }
	    s[i] = c - (<span class="d_keyword">cast</span>(<span class="d_keyword">char</span>)'a' - 'A');
	}
    }
    <span class="d_keyword">return</span> s;
}
</pre>

	<p>Copy-on-write is the protocol implemented by array processing
	functions in the D Phobos runtime library.
	</p>

<h2><a name="realtime">Real Time</a></h2>

	<p>Real time programming means that a program must be able to
	guarantee a maximum latency, or time to complete an operation.
	With most memory allocation schemes, including malloc/free and
	garbage collection, the latency is theoretically not bound.
	The most reliable way to guarantee latency is to preallocate
	all data that will be needed by the time critical portion.
	If no calls to allocate memory are done, the GC will not run
	and so will not cause the maximum latency to be exceeded.
	</p>

<h2><a name="smoothoperation">Smooth Operation</a></h2>

	<p>Related to real time programming is the need for a program to
	operate smoothly, without arbitrary pauses while the garbage
	collector stops everything to run a collection.
	An example of such a program would be an interactive shooter
	type game. Having the game play pause erratically, while not
	fatal to the program, can be annoying to the user.
	</p>

	<p>There are several techniques to eliminate or mitigate the effect:</p>

<ul>	<li>Preallocate all data needed before the part of the code
	that needs to be smooth is run.</li>

	<li>Manually run a GC collection cycle at points in program
	execution where it is already paused. An example of such a place
	would be where the program has just displayed a prompt for user
	input and the user has not responded yet.
	This reduces the odds that a collection cycle will be needed
	during the smooth code.</li>

	<li>Call std.gc.disable() before the smooth code is run, and
	std.gc.enable() afterwards. This will cause the GC to favor allocating
	more memory instead of running a collection pass.</li>
</ul>

<h2><a name="freelists">Free Lists</a></h2>

	<p>Free lists are a great way to accelerate access to a frequently
	allocated and discarded type. The idea is simple - instead of
	deallocating an object when done with it, put it on a free list.
	When allocating, pull one off the free list first.
	</p>
<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> Foo freelist;		<span class="d_comment">// start of free list
</span>
    <span class="d_keyword">static</span> Foo allocate()
    {   Foo f;

	<span class="d_keyword">if</span> (freelist)
	{   f = freelist;
	    freelist = f.next;
	}
	<span class="d_keyword">else</span>
	    f = <span class="d_keyword">new</span> Foo();
	<span class="d_keyword">return</span> f;
    }

    <span class="d_keyword">static</span> <span class="d_keyword">void</span> deallocate(Foo f)
    {
	f.next = freelist;
	freelist = f;
    }

    Foo next;		<span class="d_comment">// for use by FooFreeList
</span>    ...
}

<span class="d_keyword">void</span> test()
{
    Foo f = Foo.allocate();
    ...
    Foo.deallocate(f);
}
</pre>

	Such free list approaches can be very high performance.

	<ul>
	<li>If used by multiple threads, the allocate() and
	deallocate() functions need to be synchronized.</li>

	<li>The Foo constructor is not re-run by allocate() when
	allocating from the free list, so the allocator may need
	to reinitialize some of the members.</li>

	<li>It is not necessary to practice RAII with this, since
	if any objects are not passed to deallocate() when done, because
	of a thrown exception, they'll eventually get picked up by
	the GC anyway.</li>
	</ul>

<h2><a name="referencecounting">Reference Counting</a></h2>

	<p>The idea behind reference counting is to include a count
	field in the object. Increment it for each additional reference
	to it, and decrement it whenever a reference to it ceases.
	When the count hits 0, the object can be deleted.
	</p>

	<p>D doesn't provide any automated support for reference counting,
	it will have to be done explicitly.
	</p>

	<p><a href="windows.html#com">Win32 COM programming</a>
	uses the members AddRef() and Release()
	to maintain the reference counts.
	</p>

<h2><a name="newdelete">Explicit Class Instance Allocation</a></h2>

	<p>D provides a means of creating custom allocators and deallocators
	for class instances. Normally, these would be allocated on the
	garbage collected heap, and deallocated when the collector decides
	to run. For specialized purposes, this can be handled by
	creating <i>NewDeclaration</i>s and <i>DeleteDeclaration</i>s.
	For example, to allocate using the C runtime library's
	<tt>malloc</tt> and <tt>free</tt>:
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.c.stdlib;
<span class="d_keyword">import</span> std.outofmemory;
<span class="d_keyword">import</span> std.gc;

<span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">new</span>(size_t sz)
    {
	<span class="d_keyword">void</span>* p;

	p = std.c.stdlib.malloc(sz);
	<span class="d_keyword">if</span> (!p)
	    <span class="d_keyword">throw</span> <span class="d_keyword">new</span> OutOfMemoryException();
	std.gc.addRange(p, p + sz);
	<span class="d_keyword">return</span> p;
    }

    <span class="d_keyword">delete</span>(<span class="d_keyword">void</span>* p)
    {
	<span class="d_keyword">if</span> (p)
	{   std.gc.removeRange(p);
	    std.c.stdlib.free(p);
	}
    }
}
</pre>

	<p>The critical features of new() are:</p>

	<ul>
	<li>new() does not have a return type specified,
	but it is defined to be void*. new() must return
	a void*.</li>

	<li>If new() cannot allocate memory, it must
	not return null, but must throw an exception.</li>

	<li>The pointer returned from new() must be to memory
	aligned to the default alignment. This is 8 on win32
	systems.</li>

	<li>The <i>size</i> parameter is needed in case the
	allocator is called from a class derived from Foo and is
	a larger size than Foo.</li>

	<li>A null is not returned if storage cannot be allocated.
	Instead, an exception is thrown. Which exception gets thrown
	is up to the programmer, in this case, OutOfMemory() is.</li>

	<li>When scanning memory for root pointers into the garbage
	collected heap, the static data segment and the stack are
	scanned automatically. The C heap is not. Therefore, if Foo
	or any class derived from Foo using the allocator contains
	any references to data allocated by the garbage collector, the
	GC needs to be notified. This is done with the std.gc.addRange()
	method.</li>

	<li>No initialization of the memory is necessary, as code
	is automatically inserted after the call to new() to set the
	class instance members to their defaults and then the constructor
	(if any) is run.</li>
	</ul>

	The critical features of delete() are:

	<ul>
	<li>The destructor (if any) has already been called on the
	argument p, so the data it points to should be assumed to
	be garbage.</li>

	<li>The pointer p may be null.</li>

	<li>If the GC was notified with std.gc.addRange(), a corresponding
	call to std.gc.removeRange() must happen in the deallocator.</li>

	<li>If there is a delete(), there should be a corresponding new().</li>
	</ul>

	<p>If memory is allocated using class specific allocators and deallocators,
	careful coding practices must be followed to avoid memory leaks
	and dangling references. In the presence of exceptions, it is
	particularly important to practice RAII to prevent memory leaks.
	</p>

	<p>Custom allocators and deallocators can be done for structs
	and unions, too.</p>

<h2><a name="markrelease">Mark/Release</a></h2>

	<p>Mark/Release is equivalent to a stack method of allocating and
	freeing memory. A 'stack' is created in memory. Objects are allocated
	by simply moving a pointer down the stack. Various points are
	'marked', and then whole sections of memory are released
	simply by resetting the stack pointer back to a marked point.
	</p>

<pre class="d_code"><span class="d_keyword">import</span> std.c.stdlib;
<span class="d_keyword">import</span> std.outofmemory;

<span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> <span class="d_keyword">void</span>[] buffer;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> bufindex;
    <span class="d_keyword">static</span> <span class="d_keyword">const</span> <span class="d_keyword">int</span> bufsize = 100;

    <span class="d_keyword">static</span> <span class="d_keyword">this</span>()
    {   <span class="d_keyword">void</span> *p;

	p = malloc(bufsize);
	<span class="d_keyword">if</span> (!p)
	    <span class="d_keyword">throw</span> <span class="d_keyword">new</span> OutOfMemoryException;
	std.gc.addRange(p, p + bufsize);
	buffer = p[0 .. bufsize];
    }

    <span class="d_keyword">static</span> ~<span class="d_keyword">this</span>()
    {
	<span class="d_keyword">if</span> (buffer.length)
	{
	    std.gc.removeRange(buffer);
	    free(buffer);
	    buffer = <span class="d_keyword">null</span>;
	}
    }

    <span class="d_keyword">new</span>(size_t sz)
    {   <span class="d_keyword">void</span> *p;

	p = &amp;buffer[bufindex];
	bufindex += sz;
	<span class="d_keyword">if</span> (bufindex &gt; buffer.length)
	    <span class="d_keyword">throw</span> <span class="d_keyword">new</span> OutOfMemory;
	<span class="d_keyword">return</span> p;
    }

    <span class="d_keyword">delete</span>(<span class="d_keyword">void</span>* p)
    {
	<span class="d_keyword">assert</span>(0);
    }

    <span class="d_keyword">static</span> <span class="d_keyword">int</span> mark()
    {
	<span class="d_keyword">return</span> bufindex;
    }

    <span class="d_keyword">static</span> <span class="d_keyword">void</span> release(<span class="d_keyword">int</span> i)
    {
	bufindex = i;
    }
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> m = Foo.mark();
    Foo f1 = <span class="d_keyword">new</span> Foo;		<span class="d_comment">// allocate
</span>    Foo f2 = <span class="d_keyword">new</span> Foo;		<span class="d_comment">// allocate
</span>    ...
    Foo.release(m);		<span class="d_comment">// deallocate f1 and f2
</span>}
</pre>

	<p>The allocation of buffer[] itself is added as
	a region to the GC, so there is no need for a separate
	call inside Foo.new() to do it.</p>

<h2><a name="raii">RAII (Resource Acquisition Is Initialization)</a></h2>

	<p>RAII techniques can be useful in avoiding memory leaks
	when using explicit allocators and deallocators.
	Adding the <a href="attribute.html#scope">scope attribute</a>
	to such classes can help.
	</p>

<h2><a name="stackclass">Allocating Class Instances On The Stack</a></h2>

	<p>Class instances are normally allocated on the garbage
	collected heap. However, if they:</p>

	<ul>	<li>are allocated as local symbols in a function</li>
	<li>are allocated using <b>new</b></li>
	<li>use <b>new</b> with no arguments</li>
	<li>have the <b>scope</b> storage class</li>
	</ul>

	<p>then they are allocated on the stack. This is more efficient
	than doing an allocate/free cycle on the instance. But be
	careful that any reference to the object does not survive
	the return of the function.</p>

<pre class="d_code"><span class="d_keyword">class</span> C { ... }

<span class="d_keyword">scope</span> c = <span class="d_keyword">new</span> C();	<span class="d_comment">// c is allocated on the stack
</span></pre>

	<p>If the class has a destructor, then that destructor is
	guaranteed to be run when the class object goes out of scope,
	even if the scope is exited via an exception.</p>


<h2><a name="uninitializedarrays">Allocating Uninitialized Arrays On The Stack</a></h2>

	<p>Arrays are always initialized in D. So, the following declaration:</p>

<pre class="d_code"><span class="d_keyword">void</span> foo()
{   <span class="d_keyword">byte</span>[1024] buffer;

    fillBuffer(buffer);
    ...
}
</pre>

	<p>will not be as fast as it might be since the buffer[] contents
	are always initialized. If careful profiling of the program shows
	that this initialization is a speed problem, it can be eliminated using
	a <i>VoidInitializer</i>:
	</p>

<pre class="d_code"><span class="d_keyword">void</span> foo()
{   <span class="d_keyword">byte</span>[1024] buffer = <b><span class="d_keyword">void</span></b>;

    fillBuffer(buffer);
    ...
}
</pre>

	<p>Uninitialized data on the stack comes with some caveats that need
	to be carefully evaluated before using:
	</p>

	<ul>

	<li>The uninitialized data that is on the stack will get scanned by the
	garbage collector looking for any references to allocated memory. Since
	the uninitialized data consists of old D stack frames, it is highly
	likely that some of that garbage will look like references into the GC
	heap, and the GC memory will not get freed. This problem really does
	happen, and can be pretty frustrating to track down.</li>

	<li>It's possible for a function to pass out of it a reference to data
	on that function's stack frame. By then allocating a new stack frame
	over the old data, and not initializing, the reference to the old data
	may still appear to be valid. The program will then behave erratically.
	Initializing all data on the stack frame will greatly increase the
	probability of forcing that bug into the open in a repeatable manner.</li>

	<li>Uninitialized data can be a source of bugs and trouble, even when
	used correctly. One design goal of D is to improve reliability and
	portability by eliminating sources of undefined behavior, and
	uninitialized data is one huge source of undefined, unportable, erratic
	and unpredictable behavior. Hence this idiom should only be used after
	other opportunities for speed optimization are exhausted and if
	benchmarking shows that it really does speed up the overall execution.</li>

	</ul>

<h2><a name="isr">Interrupt Service Routines</a></h2>

	<p>When the garbage collector does a collection pass, it must
	pause all running threads in order to scan their stacks and register
	contents for references to GC allocated objects.
	If an ISR (Interrupt Service Routine) thread is paused,
	this can break the program.
	</p>

	<p>Therefore, the ISR thread should not be paused.
	Threads created with the <a href="phobos/std_thread.html">std.thread</a>
	functions will be paused. But threads created with C's
	<tt>_beginthread()</tt> or equivalent won't be, the GC
	won't know they exist.
	</p>

	<p>For this to work successfully:</p>

	<ul>
	<li>The ISR thread cannot allocate any memory using the GC.
	This means that the global <tt>new</tt> cannot be used.
	Nor can dynamic arrays be resized, nor can any elements be
	added to associative arrays. Any use of the D runtime library
	should be examined for any possibility of allocating GC memory -
	or better yet, the ISR should not call any D runtime library
	functions at all.</li>

	<li>The ISR cannot hold the sole reference to any GC allocated
	memory, otherwise the GC may free the memory while the ISR
	is still using it. The solution is to have one of the paused
	threads hold a reference to it too, or store a reference to
	it in global data.</li>

	</ul>

  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>




<div id="copyright">

Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Memory
" title="Read/write comments and feedback">Comments</a>
</div>

</body>
</html>

