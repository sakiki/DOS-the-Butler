
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Functions - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.gif" width="270" height="53" style="border-style:none" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>
	<br>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Function
" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/d/download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Thu Mar  6 15:44:00 2008
</div>
</div>

<!-- Generated by Ddoc from function.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D &rarr;</a></li>
	<li><a href="lex.html" title="D Language Specification">Language &rarr;</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos &rarr;</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons &rarr;</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D 1.0 &rarr;</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>
	<li><a href="module.html">Modules</a></li>
	<li><a href="declaration.html">Declarations</a></li>
	<li><a href="type.html">Types</a></li>
	<li><a href="property.html">Properties</a></li>
	<li><a href="attribute.html">Attributes</a></li>
	<li><a href="pragma.html">Pragmas</a></li>
	<li><a href="expression.html">Expressions</a></li>
	<li><a href="statement.html">Statements</a></li>
	<li><a href="arrays.html">Arrays</a></li>
	<li><a href="struct.html">Structs &amp; Unions</a></li>
	<li><a href="class.html">Classes</a></li>
	<li><a href="interface.html">Interfaces</a></li>
	<li><a href="enum.html">Enums</a></li>
	<li><a href="const3.html">Const and Invariant</a></li>
	<li><a href="function.html">Functions</a></li>
	<li><a href="operatoroverloading.html">Operator Overloading</a></li>
	<li><a href="template.html">Templates</a></li>
	<li><a href="template-mixin.html">Template Mixins</a></li>
	<li><a href="dbc.html">Contracts</a></li>
	<li><a href="version.html">Conditional Compilation</a></li>
	<li><a href="traits.html">Traits</a></li>
	<li><a href="errors.html">Handling errors</a></li>
	<li><a href="garbage.html">Garbage Collection</a></li>
	<li><a href="float.html">Floating Point</a></li>
	<li><a href="iasm.html">Inline Assembler</a></li>
	<li><a href="ddoc.html">Documentation Comments</a></li>
	<li><a href="interfaceToC.html">Interfacing To C</a></li>
	<li><a href="cpp_interface.html">Interfacing To C++</a></li>
	<li><a href="portability.html">Portability Guide</a></li>
	<li><a href="html.html">Embedding D in HTML</a></li>
	<li><a href="entity.html">Named Character Entities</a></li>
	<li><a href="abi.html">Application Binary Interface</a></li>
    </ul>
    </div>
    
<form action="http://www.google.com/translate" onsubmit="this.u.value=window.location.href" method="GET">
<input value="en" name="hl" type="hidden"/>
<input value="UTF8" name="ie" type="hidden"/>
<input value="" name="u" type="hidden"/>
<select name="langpair">
<option value="en|de"/>German
<option value="en|fr"/>French
<option value="en|it"/>Italian
<option value="en|pt"/>Portuguese
<option value="en|es"/>Spanish
<option value="en|ar"/>Arabic
<option value="en|zh-CN"/>Chinese (Simplified)
<option value="en|ja"/>Japanese
<option value="en|ko"/>Korean
<option value="en|ru"/>Russian
</select><br/>
<input value="Translate" type="submit"/>
</form>


    
<br><br>
<br><br>
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/* 180x150, created 2/18/08 */
/**/google_ad_slot = "4228873179";
/**/google_ad_width = 180;
/**/google_ad_height = 150;
/**/google_cpa_choice = ""; // on file
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>



</div>
<div id="content">
  <h1>     Functions</h1>
  
<pre class="bnf"><i>FunctionBody</i>:
	<i>BlockStatement</i>
	<i>BodyStatement</i>
	<i>InStatement</i> <i>BodyStatement</i>
	<i>OutStatement</i> <i>BodyStatement</i>
	<i>InStatement</i> <i>OutStatement</i> <i>BodyStatement</i>
	<i>OutStatement</i> <i>InStatement</i> <i>BodyStatement</i>

<i>InStatement</i>:
	<b>in</b> <i>BlockStatement</i>

<i>OutStatement</i>:
	<b>out</b> <i>BlockStatement</i>
	<b>out</b> <b>(</b> <i>Identifier</i> <b>)</b> <i>BlockStatement</i>

<i>BodyStatement</i>:
	<b>body</b> <i>BlockStatement</i>
</pre>

<h3>Virtual Functions</h3>

	Virtual functions are functions that are called indirectly
	through a function
	pointer table, called a vtbl[], rather than directly.
	All non-static non-private non-template member functions are virtual.
	This may sound
	inefficient, but since the D compiler knows all of the class
	hierarchy when generating code, all
	functions that are not overridden can be optimized to be non-virtual.
	In fact, since
	C++ programmers tend to "when in doubt, make it virtual", the D way of
	"make it
	virtual unless we can prove it can be made non-virtual" results, on
	average, in many
	more direct function calls. It also results in fewer bugs caused by
	not declaring
	a function virtual that gets overridden.
	<p>

	Functions with non-D linkage cannot be virtual, and hence cannot be
	overridden.
	<p>

	Member template functions cannot be virtual, and hence cannot be
	overridden.
	<p>

	Functions marked as <tt>final</tt> may not be overridden in a
	derived class, unless they are also <tt>private</tt>.
	For example:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> def() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">int</span> foo() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">private</span> <span class="d_keyword">int</span> bar() { ... }
    <span class="d_keyword">private</span> <span class="d_keyword">int</span> abc() { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">int</span> def() { ... }	<span class="d_comment">// ok, overrides A.def
</span>    <span class="d_keyword">int</span> foo() { ... }	<span class="d_comment">// error, A.foo is final
</span>    <span class="d_keyword">int</span> bar() { ... }	<span class="d_comment">// ok, A.bar is final private, but not virtual
</span>    <span class="d_keyword">int</span> abc() { ... }	<span class="d_comment">// ok, A.abc is not virtual, B.abc is virtual
</span>}

<span class="d_keyword">void</span> test(A a)
{
    a.def();	<span class="d_comment">// calls B.def
</span>    a.foo();	<span class="d_comment">// calls A.foo
</span>    a.bar();	<span class="d_comment">// calls A.bar
</span>    a.abc();	<span class="d_comment">// calls A.abc
</span>}

<span class="d_keyword">void</span> func()
{   B b = <span class="d_keyword">new</span> B();
    test(b);
}
</pre>

	<a name="covariant">Covariant return types</a>
	are supported, which means that the
	overriding function in a derived class can return a type
	that is derived from the type returned by the overridden function:

<pre class="d_code"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">class</span> Foo
{
    A test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }
}

<span class="d_keyword">class</span> Bar : Foo
{
    B test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }	<span class="d_comment">// overrides and is covariant with Foo.test()
</span>}
</pre>

<h3>Function Inheritance and Overriding</h3>

	A functions in a derived class with the same name and parameter
	types as a function in a base class overrides that function:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo(1);	<span class="d_comment">// calls B.foo(int)
</span>}
</pre>

	<p>However, when doing overload resolution, the functions in the base
	class are not considered:
	</p>

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    b.foo(1);	<span class="d_comment">// calls B.foo(long), since A.foo(int) not considered
</span>    A a = b;
    a.foo(1);	<span class="d_comment">// issues runtime error (instead of calling A.foo(int))</span>
}
</pre>

	<p>To consider the base class's functions in the overload resolution
	process, use an <i>AliasDeclaration</i>:
	</p>

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <b><span class="d_keyword">alias</span> A.foo foo;</b>
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo(1);		<span class="d_comment">// calls A.foo(int)
</span>    B b = <span class="d_keyword">new</span> B();
    b.foo(1);		<span class="d_comment">// calls A.foo(int)
</span>}
</pre>

	<p>If such an <i>AliasDeclaration</i> is not used, the derived
	class's functions completely override all the functions of the
	same name in the base class, even if the types of the parameters
	in the base class functions are different. If, through
	implicit conversions to the base class, those other functions do
	get called, an <tt>std.HiddenFuncError</tt> exception is raised:
	</p>
<pre class="d_code"><span class="d_keyword">import</span> std.hiddenfunc;

<span class="d_keyword">class</span> A
{
     <span class="d_keyword">void</span> set(<span class="d_keyword">long</span> i) { }
     <span class="d_keyword">void</span> <b>set</b>(<span class="d_keyword">int</span> i)  { }
}
<span class="d_keyword">class</span> B : A
{
     <span class="d_keyword">void</span> set(<span class="d_keyword">long</span> i) { }
}

<span class="d_keyword">void</span> foo(A a)
{   <span class="d_keyword">int</span> i;
    <span class="d_keyword">try</span>
    {
        a.<b>set</b>(3);   <span class="d_comment">// error, throws runtime exception since
</span>                    <span class="d_comment">// A.set(int) should not be available from B
</span>    }
    <span class="d_keyword">catch</span> (<b>HiddenFuncError</b> o)
    {
	i = 1;
    }
    <span class="d_keyword">assert</span>(i == 1);
}

<span class="d_keyword">void</span> main()
{
    foo(<span class="d_keyword">new</span> B);
}
</pre>
	<p>If an <tt>HiddenFuncError</tt> exception is thrown in your program,
	the use of overloads and overrides needs to be reexamined in the
	relevant classes.</p>


	<p>A function parameter's default value is not inherited:</p>

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x = 5</b>) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x = 7</b>) { ... }
}

<span class="d_keyword">class</span> C : B
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x</b>) { ... }
}


<span class="d_keyword">void</span> test()
{
    A a = <span class="d_keyword">new</span> A();
    a.foo();		<span class="d_comment">// calls A.foo(5)
</span>
    B b = <span class="d_keyword">new</span> B();
    b.foo();		<span class="d_comment">// calls B.foo(7)
</span>
    C c = <span class="d_keyword">new</span> C();
    c.foo();		<span class="d_comment">// error, need an argument for C.foo
</span>}
</pre>


<h3>Inline Functions</h3>

	There is no inline keyword. The compiler makes the decision whether to 
	inline a function or not, analogously to the register keyword no
	longer being relevant to a 
	compiler's decisions on enregistering variables.
	(There is no register keyword either.)


<h2><a name="function-overloading">Function Overloading</a></h2>

	<p>In C++, there are many complex levels of function overloading, with
	some defined as "better" matches than others. If the code designer
	takes advantage of the more subtle 
	behaviors of overload function selection, the code can become
	difficult to maintain. Not 
	only will it take a C++ expert to understand why one function is
	selected over another, but different C++ compilers can implement
	this tricky feature differently, producing 
	subtly disastrous results.
	</p>

	<p>In D, function overloading is simple. It matches exactly, it matches
	with implicit conversions, or it does not match. If there is more than
	one match, it is an error.
	</p>

	<p>Functions defined with non-D linkage cannot be overloaded.
	</p>

<h2><a name="overload-sets">Overload Sets</a></h2>

	<p>Functions declared at the same scope overload against each
	other, and are called an <i>Overload Set</i>.
	A typical example of an overload set are functions defined
	at module level:
	</p>

<pre class="d_code"><span class="d_keyword">module</span> A;
<span class="d_keyword">void</span> foo() { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">long</span> i) { }
</pre>

	<p><tt>A.foo()</tt> and <tt>A.foo(long)</tt> form an overload set.
	A different module can also define functions with the same name:
	</p>

<pre class="d_code"><span class="d_keyword">module</span> B;
<span class="d_keyword">class</span> C { }
<span class="d_keyword">void</span> foo(C) { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> i) { }
</pre>

	<p>and A and B can be imported by a third module, C.
	Both overload sets, the <tt>A.foo</tt> overload set and the <tt>B.foo</tt>
	overload set, are found. An instance of <tt>foo</tt> is selected
	based on it matching in exactly one overload set:
	</p>

<pre class="d_code"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">void</span> bar(C c)
{
    foo();    <span class="d_comment">// calls A.foo()
</span>    foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>    foo(c);   <span class="d_comment">// calls B.foo(C)
</span>    foo(1,2); <span class="d_comment">// error, does not match any foo
</span>    foo(1);   <span class="d_comment">// error, matches A.foo(long) and B.foo(int)
</span>    A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</pre>

	<p>Even though <tt>B.foo(int)</tt> is a better match than <tt>	A.foo(long)</tt> for <tt>foo(1)</tt>,
	it is an error because the two matches are in
	different overload sets.
	</p>

	<p>Overload sets can be merged with an alias declaration:</p>

<pre class="d_code"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">alias</span> A.foo foo;
<span class="d_keyword">alias</span> B.foo foo;

<span class="d_keyword">void</span> bar(C c)
{
    foo();    <span class="d_comment">// calls A.foo()
</span>    foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>    foo(c);   <span class="d_comment">// calls B.foo(C)
</span>    foo(1,2); <span class="d_comment">// error, does not match any foo
</span>    foo(1);   <span class="d_comment">// calls B.foo(int)
</span>    A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</pre>




<h3><a name="parameters">Function Parameters</a></h3>


	Parameter storage classes are <b>in</b>, <b>out</b>,
	<b>ref</b>, <b>lazy</b>, <b>final</b>, <b>const</b>, <b>invariant</b>, or
	<b>scope</b>.
	 For example:

<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">in</span> <span class="d_keyword">int</span> x, <span class="d_keyword">out</span> <span class="d_keyword">int</span> y, <span class="d_keyword">ref</span> <span class="d_keyword">int</span> z, <span class="d_keyword">int</span> q);
</pre>

	<p>	x is <b>in</b>, y is <b>out</b>, z is <b>ref</b>, and q is none.
	</p>

	<p>	The <b>in</b> storage class is equivalent to <b>const scope</b>.
	</p>

	<p>	If no storage class is specified, the parameter becomes a mutable
	copy of its argument.
	</p>


	<ul>
	<li>The function declaration makes it clear what the inputs and
	outputs to the function are.</li>
	<li>It eliminates the need for IDL as a separate language.</li>
	<li>It provides more information to the compiler, enabling more
	error checking and 
	possibly better code generation.</li>
	</ul>

	<p>	<b>out</b> parameters are set to the default initializer for the
	type of it. For example:
	</p>
<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x)
{
    <span class="d_comment">// x is set to 0 at start of foo()
</span>}

<span class="d_keyword">int</span> a = 3;
foo(a);
<span class="d_comment">// a is now 0
</span>

<span class="d_keyword">void</span> abc(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x)
{
    x = 2;
}

<span class="d_keyword">int</span> y = 3;
abc(y);
<span class="d_comment">// y is now 2
</span>

<span class="d_keyword">void</span> def(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x)
{
    x += 1;
}

<span class="d_keyword">int</span> z = 3;
def(z);
<span class="d_comment">// z is now 4
</span></pre>

	<p>For dynamic array and object parameters, which are passed
	by reference, in/out/ref
	apply only to the reference and not the contents.
	</p>

	<p>Lazy arguments are evaluated not when the function is called,
	but when the parameter is evaluated within the function. Hence,
	a lazy argument can be executed 0 or more times. A lazy parameter
	cannot be an lvalue.</p>

<pre class="d_code"><span class="d_keyword">void</span> dotimes(<span class="d_keyword">int</span> n, <span class="d_keyword">lazy</span> <span class="d_keyword">void</span> exp)
{
    <span class="d_keyword">while</span> (n--)
	exp();
}

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> x;
    dotimes(3, writefln(x++));
}
</pre>

	<p>prints to the console:</p>

<pre class="console">0
1
2
</pre>

	<p>A lazy parameter of type <tt>void</tt> can accept an argument
	of any type.</p>

<a name="variadic"><h2>Variadic Functions</h2></a>

	Functions taking a variable number of arguments are called
	variadic functions. A variadic function can take one of
	three forms:

	<ol>	<li>C-style variadic functions</li>
	<li>Variadic functions with type info</li>
	<li>Typesafe variadic functions</li>
	</ol>


<h3>C-style Variadic Functions</h3>

	A C-style variadic function is declared as taking
	a parameter of ... after the required function parameters.
	It has non-D linkage, such as <tt>extern (C)</tt>:

<pre class="d_code"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...);

foo(3, 4);	<span class="d_comment">// ok
</span>foo(3, 4, 6.8);	<span class="d_comment">// ok, one variadic argument
</span>foo(2);		<span class="d_comment">// error, y is a required argument
</span></pre>

	There must be at least one non-variadic parameter declared.

<pre class="d_code"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> def(...); <span class="d_comment">// error, must have at least one parameter
</span></pre>

	C-style variadic functions match the C calling convention for
	variadic functions, and is most useful for calling C library
	functions like <tt>printf</tt>.
	The implementiations of these variadic functions have a special
	local variable declared for them,
	<b>_argptr</b>, which is a <tt>void*</tt> pointer to the first of the
	variadic
	arguments. To access the arguments, <b>_argptr</b> must be cast
	to a pointer to the expected argument type:

<pre class="d_code">foo(3, 4, 5);	<span class="d_comment">// first variadic argument is 5
</span>
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{   <span class="d_keyword">int</span> z;

    z = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)<b>_argptr</b>;	<span class="d_comment">// z is set to 5
</span>}
</pre>

	To protect against the vagaries of stack layouts on different
	CPU architectures, use <b>std.c.stdarg</b> to access the variadic
	arguments:

<pre class="d_code"><span class="d_keyword">import</span> <b>std.c.stdarg</b>;
</pre>

<h3>D-style Variadic Functions</h3>

	Variadic functions with argument and type info are declared as taking
	a parameter of ... after the required function parameters.
	It has D linkage, and need not have any non-variadic parameters
	declared:

<pre class="d_code"><span class="d_keyword">int</span> abc(<span class="d_keyword">char</span> c, ...);	<span class="d_comment">// one required parameter: c
</span><span class="d_keyword">int</span> def(...);		<span class="d_comment">// ok
</span></pre>

	These variadic functions have a special local variable declared for
	them,
	<b>_argptr</b>, which is a <tt>void*</tt> pointer to the first of the
	variadic
	arguments. To access the arguments, <b>_argptr</b> must be cast
	to a pointer to the expected argument type:

<pre class="d_code">foo(3, 4, 5);	<span class="d_comment">// first variadic argument is 5
</span>
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{   <span class="d_keyword">int</span> z;

    z = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)<b>_argptr</b>;	<span class="d_comment">// z is set to 5
</span>}
</pre>

	An additional hidden argument
	with the name <b>_arguments</b> and type <tt>TypeInfo[]</tt>
	is passed to the function.
	<b>_arguments</b> gives the number of arguments and the type
	of each, enabling the creation of typesafe variadic functions.

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> Foo { <span class="d_keyword">int</span> x = 3; }
<span class="d_keyword">class</span> Bar { <span class="d_keyword">long</span> y = 4; }

<span class="d_keyword">void</span> printargs(<span class="d_keyword">int</span> x, ...)
{
    writefln(<span class="d_string">"%d arguments"</span>, <b>_arguments</b>.length);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; <b>_arguments</b>.length; i++)
    {   <b>_arguments</b>[i].print();

	<span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
	{
	    <span class="d_keyword">int</span> j = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span> *)_argptr;
	    _argptr += <span class="d_keyword">int</span>.sizeof;
	    writefln(<span class="d_string">"\t%d"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
	{
	    <span class="d_keyword">long</span> j = *<span class="d_keyword">cast</span>(<span class="d_keyword">long</span> *)_argptr;
	    _argptr += <span class="d_keyword">long</span>.sizeof;
	    writefln(<span class="d_string">"\t%d"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
	{
	    <span class="d_keyword">double</span> d = *<span class="d_keyword">cast</span>(<span class="d_keyword">double</span> *)_argptr;
	    _argptr += <span class="d_keyword">double</span>.sizeof;
	    writefln(<span class="d_string">"\t%g"</span>, d);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(Foo))
	{
	    Foo f = *<span class="d_keyword">cast</span>(Foo*)_argptr;
	    _argptr += Foo.sizeof;
	    writefln(<span class="d_string">"\t%X"</span>, f);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(Bar))
	{
	    Bar b = *<span class="d_keyword">cast</span>(Bar*)_argptr;
	    _argptr += Bar.sizeof;
	    writefln(<span class="d_string">"\t%X"</span>, b);
	}
	<span class="d_keyword">else</span>
	    <span class="d_keyword">assert</span>(0);
    }
}

<span class="d_keyword">void</span> main()
{
    Foo f = <span class="d_keyword">new</span> Foo();
    Bar b = <span class="d_keyword">new</span> Bar();

    writefln(<span class="d_string">"%X"</span>, f);
    printargs(1, 2, 3L, 4.5, f, b);
}
</pre>

	which prints:

<pre class="d_code">00870FE0
5 arguments
<span class="d_keyword">int</span>
        2
<span class="d_keyword">long</span>
        3
<span class="d_keyword">double</span>
        4.5
Foo
        00870FE0
Bar
        00870FD0
</pre>

	To protect against the vagaries of stack layouts on different
	CPU architectures, use <b>std.stdarg</b> to access the variadic
	arguments:

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> <b>std.stdarg</b>;

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, ...)
{
    writefln(<span class="d_string">"%d arguments"</span>, _arguments.length);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; _arguments.length; i++)
    {   _arguments[i].print();

	<span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
	{
	    <span class="d_keyword">int</span> j = <b>va_arg</b>!(<span class="d_keyword">int</span>)(_argptr);
	    writefln(<span class="d_string">"\t%d"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
	{
	    <span class="d_keyword">long</span> j = <b>va_arg</b>!(<span class="d_keyword">long</span>)(_argptr);
	    writefln(<span class="d_string">"\t%d"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
	{
	    <span class="d_keyword">double</span> d = <b>va_arg</b>!(<span class="d_keyword">double</span>)(_argptr);
	    writefln(<span class="d_string">"\t%g"</span>, d);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(FOO))
	{
	    FOO f = <b>va_arg</b>!(FOO)(_argptr);
	    writefln(<span class="d_string">"\t%X"</span>, f);
	}
	<span class="d_keyword">else</span>
	    <span class="d_keyword">assert</span>(0);
    }
}
</pre>

<h3>Typesafe Variadic Functions</h3>

	Typesafe variadic functions are used when the variable argument
	portion of the arguments are used to construct an array or
	class object.
	<p>

	For arrays:

<pre class="d_code"><span class="d_keyword">int</span> test()
{
    <span class="d_keyword">return</span> sum(1, 2, 3) + sum(); <span class="d_comment">// returns 6+0
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">return</span> sum(ii);		<span class="d_comment">// returns 15
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
	s += x;
    <span class="d_keyword">return</span> s;
}
</pre>

	For static arrays:

<pre class="d_code"><span class="d_keyword">int</span> test()
{
    <span class="d_keyword">return</span> sum(2, 3);	<span class="d_comment">// error, need 3 values for array
</span>    <span class="d_keyword">return</span> sum(1, 2, 3); <span class="d_comment">// returns 6
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">int</span>[] jj = ii;
    <span class="d_keyword">return</span> sum(ii);		<span class="d_comment">// returns 15
</span>    <span class="d_keyword">return</span> sum(jj);		<span class="d_comment">// error, type mismatch
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[3] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
	s += x;
    <span class="d_keyword">return</span> s;
}
</pre>

	For class objects:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">char</span>[] s;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x, <span class="d_keyword">char</span>[] s)
    {
	<span class="d_keyword">this</span>.x = x;
	<span class="d_keyword">this</span>.s = s;
    }
}

<span class="d_keyword">void</span> test(<span class="d_keyword">int</span> x, Foo f ...);

...

Foo g = <span class="d_keyword">new</span> Foo(3, <span class="d_string">"abc"</span>);
test(1, g);		<span class="d_comment">// ok, since g is an instance of Foo
</span>test(1, 4, <span class="d_string">"def"</span>);	<span class="d_comment">// ok
</span>test(1, 5);		<span class="d_comment">// error, no matching constructor for Foo
</span></pre>

	An implementation may construct the object or array instance
	on the stack. Therefore, it is an error to refer to that
	instance after the variadic function has returned:

<pre class="d_code">Foo test(Foo f ...)
{
    <span class="d_keyword">return</span> f;	<span class="d_comment">// error, f instance contents invalid after return
</span>}

<span class="d_keyword">int</span>[] test(<span class="d_keyword">int</span>[] a ...)
{
    <span class="d_keyword">return</span> a;		<span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a[0..1];	<span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a.dup;	<span class="d_comment">// ok, since copy is made
</span>}
</pre>

	For other types, the argument is built with itself, as in:

<pre class="d_code"><span class="d_keyword">int</span> test(<span class="d_keyword">int</span> i ...)
{
    <span class="d_keyword">return</span> i;
}

...
test(3);	<span class="d_comment">// returns 3
</span>test(3, 4);	<span class="d_comment">// error, too many arguments
</span><span class="d_keyword">int</span>[] x;
test(x);	<span class="d_comment">// error, type mismatch
</span></pre>

<h3>Lazy Variadic Functions</h3>

	<p>If the variadic parameter is an array of delegates
	with no parameters:
	</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>()[] dgs ...);
</pre>

	<p>Then each of the arguments whose type does not match that
	of the delegate is converted to a delegate.
	</p>

<pre class="d_code"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
foo(1, 3+x, dg, <span class="d_keyword">cast</span>(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>())<span class="d_keyword">null</span>);
</pre>

	<p>is the same as:</p>

<pre class="d_code">foo( { <span class="d_keyword">return</span> 1; }, { <span class="d_keyword">return</span> 3+x; }, dg, <span class="d_keyword">null</span> );
</pre>

<h2>Local Variables</h2>

	<p>It is an error to use a local variable without first assigning it a
	value. The implementation may not always be able to detect these
	cases. Other language compilers sometimes issue a warning for this,
	but since it is always a bug, it should be an error.
	</p>

	<p>It is an error to declare a local variable that is never referred to.
	Dead variables, like anachronistic dead code, are just a source of
	confusion for maintenance programmers.
	</p>

	<p>It is an error to declare a local variable that hides another local
	variable in the same function:
	</p>

<pre class="d_code"><span class="d_keyword">void</span> func(<span class="d_keyword">int</span> x)
{   <span class="d_keyword">int</span> x;		error, hides previous definition of x
     <span class="d_keyword">double</span> y;
     ...
     {   <span class="d_keyword">char</span> y;	error, hides previous definition of y
	  <span class="d_keyword">int</span> z;
     }
     {   <span class="d_keyword">wchar</span> z;	legal, previous z <span class="d_keyword">is</span> <span class="d_keyword">out</span> of <span class="d_keyword">scope</span>
     }
}
</pre>

	<p>While this might look unreasonable, in practice whenever
	this is done it either is a 
	bug or at least looks like a bug.
	</p>

	<p>It is an error to return the address of or a reference to a
	local variable.
	</p>

	<p>It is an error to have a local variable and a label with the same
	name.
	</p>

<h2><a name="nested">Nested Functions</a></h2>

	<p>Functions may be nested within other functions:</p>

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	<span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> 1; }

	<span class="d_keyword">return</span> b + abc();
    }
    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);	<span class="d_comment">// i is assigned 4
</span>}
</pre>

	<p>Nested functions can be accessed only if the name is in scope.</p>

<pre class="d_code"><span class="d_keyword">void</span> foo()
{
   <span class="d_keyword">void</span> A()
   {
     B();   <span class="d_comment">// error, B() is forward referenced
</span>     C();   <span class="d_comment">// error, C undefined
</span>   }
   <span class="d_keyword">void</span> B()
   {
       A();	<span class="d_comment">// ok, in scope
</span>       <span class="d_keyword">void</span> C()
       {
           <span class="d_keyword">void</span> D()
           {
               A();      <span class="d_comment">// ok
</span>               B();      <span class="d_comment">// ok
</span>               C();      <span class="d_comment">// ok
</span>               D();      <span class="d_comment">// ok
</span>           }
       }
   }
   A(); <span class="d_comment">// ok
</span>   B(); <span class="d_comment">// ok
</span>   C(); <span class="d_comment">// error, C undefined
</span>}
</pre>

	<p>and:</p>

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> b + 1; }
    <span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> foo(b); }	<span class="d_comment">// ok
</span>    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);	<span class="d_comment">// ok
</span>    <span class="d_keyword">int</span> j = bar.foo(3);	<span class="d_comment">// error, bar.foo not visible
</span>}
</pre>

	<p>Nested functions have access to the variables and other symbols
	defined by the lexically enclosing function.
	This access includes both the ability to read and write them.
	</p>

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{   <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	b += c;		<span class="d_comment">// 4 is added to b
</span>	c++;		<span class="d_comment">// bar.c is now 5
</span>	<span class="d_keyword">return</span> b + c;	<span class="d_comment">// 12 is returned
</span>    }
    c = 4;
    <span class="d_keyword">int</span> i = foo(a);	<span class="d_comment">// i is set to 12
</span>    <span class="d_keyword">return</span> i + c;	<span class="d_comment">// returns 17
</span>}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);	<span class="d_comment">// i is assigned 17
</span>}
</pre>

	<p>This access can span multiple nesting levels:</p>

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{   <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	<span class="d_keyword">int</span> abc()
	{
	    <span class="d_keyword">return</span> c;	<span class="d_comment">// access bar.c
</span>	}
	<span class="d_keyword">return</span> b + c + abc();
    }
    <span class="d_keyword">return</span> foo(3);
}
</pre>

	<p>Static nested functions cannot access any stack variables of
	any lexically enclosing function, but can access static variables.
	This is analogous to how static member functions behave.
	</p>

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{   <span class="d_keyword">int</span> c;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> d;

    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	b = d;		<span class="d_comment">// ok
</span>	b = c;		<span class="d_comment">// error, foo() cannot access frame of bar()
</span>	<span class="d_keyword">return</span> b + 1;
    }
    <span class="d_keyword">return</span> foo(a);
}
</pre>

	<p>Functions can be nested within member functions:</p>

<pre class="d_code"><span class="d_keyword">struct</span> Foo
{   <span class="d_keyword">int</span> a;

    <span class="d_keyword">int</span> bar()
    {   <span class="d_keyword">int</span> c;

	<span class="d_keyword">int</span> foo()
	{
	    <span class="d_keyword">return</span> c + a;
	}
	<span class="d_keyword">return</span> 0;
    }
}
</pre>

	<p>Member functions of nested classes and structs do not have
	access to the stack variables of the enclosing function, but
	do have access to the other symbols:
	</p>

<pre class="d_code"><span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> j;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> s;

    <span class="d_keyword">struct</span> Foo
    {   <span class="d_keyword">int</span> a;

	<span class="d_keyword">int</span> bar()
	{   <span class="d_keyword">int</span> c = s;		<span class="d_comment">// ok, s is static
</span>	    <span class="d_keyword">int</span> d = j;		<span class="d_comment">// error, no access to frame of test()
</span>
	    <span class="d_keyword">int</span> foo()
	    {
		<span class="d_keyword">int</span> e = s;	<span class="d_comment">// ok, s is static
</span>		<span class="d_keyword">int</span> f = j;	<span class="d_comment">// error, no access to frame of test()
</span>		<span class="d_keyword">return</span> c + a;	<span class="d_comment">// ok, frame of bar() is accessible,
</span>				<span class="d_comment">// so are members of Foo accessible via
</span>				<span class="d_comment">// the 'this' pointer to Foo.bar()
</span>	    }

	    <span class="d_keyword">return</span> 0;
	}
    }
}
</pre>

	<p>Nested functions always have the D function linkage type.
	</p>

	<p>Unlike module level declarations, declarations within function
	scope are processed in order. This means that two nested functions
	cannot mutually call each other:
	</p>

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> foo() { bar(); }	<span class="d_comment">// error, bar not defined
</span>    <span class="d_keyword">void</span> bar() { foo(); }	<span class="d_comment">// ok
</span>}
</pre>

	<p>The solution is to use a delegate:</p>

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() fp;
    <span class="d_keyword">void</span> foo() { fp(); }
    <span class="d_keyword">void</span> bar() { foo(); }
    fp = &amp;bar;
}
</pre>

	<p><b>Future directions:</b> This restriction may be removed.</p>


<h3><a name="closures">Delegates, Function Pointers, and  Closures</a></h3>

	<p>A function pointer can point to a static nested function:</p>

<pre class="d_code"><span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">static</span> <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    fp = &amp;foo;
}

<span class="d_keyword">void</span> bar()
{
    test();
    <span class="d_keyword">int</span> i = fp();	<span class="d_comment">// i is set to 10
</span>}
</pre>

	<p>A delegate can be set to a non-static nested function:</p>

<pre class="d_code"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    dg = &amp;foo;
    <span class="d_keyword">int</span> i = dg();	<span class="d_comment">// i is set to 10
</span>}
</pre>


	<p>The stack variables referenced by a nested function are
	still valid even after the function exits (this is different
	from D 1.0). This is called a <i>closure</i>.
	Returning addresses of stack variables, however, is not
	a closure and is an error.
	</p>

<pre class="d_code"><span class="d_keyword">int</span>* bar()
{   <span class="d_keyword">int</span> b;
    test();
    <span class="d_keyword">int</span> i = dg();	<span class="d_comment">// ok, test.a is in a closure and still exists
</span>    <span class="d_keyword">return</span> &amp;b;		<span class="d_comment">// error, bar.b not valid after bar() exits
</span>}
</pre>


	<p>Delegates to non-static nested functions contain two pieces of
	data: the pointer to the stack frame of the lexically enclosing
	function (called the <i>frame pointer</i>) and the address of the
	function. This is analogous to struct/class non-static member
	function delegates consisting of a <i>this</i> pointer and
	the address of the member function.
	Both forms of delegates are interchangeable, and are actually
	the same type:
	</p>

<pre class="d_code"><span class="d_keyword">struct</span> Foo
{   <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> a; }
}

<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg)
{
    <span class="d_keyword">return</span> dg() + 1;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> x = 27;
    <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> x; }
    Foo f;
    <span class="d_keyword">int</span> i;

    i = foo(&amp;abc);	<span class="d_comment">// i is set to 28
</span>    i = foo(&amp;f.bar);	<span class="d_comment">// i is set to 8
</span>}
</pre>

	<p>This combining of the environment and the function is called
	a <i>dynamic closure</i>.
	</p>

	<p>The <b>.ptr</b> property of a delegate will return the
	<i>frame pointer</i> value as a <tt>void*</tt>.
	</p>

	<p>The <b>.funcptr</b> property of a delegate will return the
	<i>function pointer</i> value as a function type.
	</p>

	<p><b>Future directions:</b> Function pointers and delegates may merge
	into a common syntax and be interchangeable with each other.
	</p>

<h3>Anonymous Functions and Anonymous Delegates</h3>

	<p>See <a href="expression.html#FunctionLiteral">Function Literals</a>.
	</p>

<h2>main() Function</h2>

	<p>For console programs, <tt>main()</tt> serves as the entry point.
	It gets called after all the module initializers are run, and
	after any unittests are run.
	After it returns, all the module destructors are run.
	<tt>main()</tt> must be declared using one of the following forms:
	</p>

<pre class="d_code"><span class="d_keyword">void</span> main() { ... }
<span class="d_keyword">void</span> main(<span class="d_keyword">char</span>[][] args) { ... }
<span class="d_keyword">int</span> main() { ... }
<span class="d_keyword">int</span> main(<span class="d_keyword">char</span>[][] args) { ... }
</pre>

<h2><a name="interpretation">Compile Time Function Execution</a></h2>

	<p>A subset of functions can be executed at compile time.
	This is useful when constant folding algorithms need to
	include recursion and looping.
	In order to be executed at compile time, a function must
	meet the following criteria:
	</p>

	<ol>
	<li>function arguments must all be:
	    <ul>		<li>integer literals</li>
		<li>floating point literals</li>
		<li>character literals</li>
		<li>string literals</li>
		<li>array literals where the members are all items
		in this list</li>
		<li>associative array literals where the members are all items
		in this list</li>
		<li>struct literals where the members are all items
		in this list</li>
		<li>const variables initialized with a member of
		this list</li>
	    </ul>
	</li>

	<li>function parameters may not be variadic,
	or <b>lazy</b></li>

	<li>the function may not be nested or synchronized</li>

	<li>the function may not be a non-static member, i.e.
	it may not have a <tt>this</tt> pointer</li>

	<li>expressions in the function may not:
	    <ul>		<li>throw exceptions</li>
		<li>use pointers, delegates, non-const arrays,
		or classes</li>
		<li>reference any global state or variables</li>
		<li>reference any local static variables</li>
		<li>new or delete</li>
		<li>call any function that is not
		executable at compile time</li>
	    </ul>
	</li>

	<li>the following statement types are not allowed:
	    <ul>		<li>synchronized statements</li>
		<li>throw statements</li>
		<li>with statements</li>
		<li>scope statements</li>
		<li>try-catch-finally statements</li>
		<li>labelled break and continue statements</li>
	     </ul>
	</li>

	<li>as a special case, the following properties
	can be executed at compile time:
		<table border=1 cellpadding=4 cellspacing=0>		<tr><td><tt>.dup</tt></td></tr>
		<tr><td><tt>.length</tt></td></tr>
		<tr><td><tt>.keys</tt></td></tr>
		<tr><td><tt>.values</tt></td></tr>
		</table>
	</li>

	</ol>

	<p>In order to be executed at compile time, the function
	must appear in a context where it must be so executed, for
	example:</p>

	<ul>	<li>initialization of a static variable</li>
	<li>dimension of a static array</li>
	<li>argument for a template value parameter</li>
	</ul>

<pre class="d_code"><span class="d_keyword">template</span> eval( A... )
{
    <span class="d_keyword">const</span> <span class="d_keyword">typeof</span>(A[0]) eval = A[0];
}

<span class="d_keyword">int</span> square(<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> i * i; }

<span class="d_keyword">void</span> foo()
{
  <span class="d_keyword">static</span> j = square(3);     <span class="d_comment">// compile time
</span>  writefln(j);
  writefln(square(4));      <span class="d_comment">// run time
</span>  writefln(eval!(square(5))); <span class="d_comment">// compile time
</span>}
</pre>

	<p>Executing functions at compile time can take considerably
	longer than executing it at run time.
	If the function goes into an infinite loop, it will hang at
	compile time (rather than hanging at run time).
	</p>

	<p>Functions executed at compile time can give different results
	from run time in the following scenarios:
	</p>

	<ul>
	<li>floating point computations may be done at a higher
	precision than run time</li>
	<li>dependency on implementation defined order of evaluation</li>
	<li>use of uninitialized variables</li>

	</ul>

	<p>These are the same kinds of scenarios where different
	optimization settings affect the results.</p>

<h3>String Mixins and Compile Time Function Execution</h3>

	<p>Any functions that execute at compile time must also
	be executable at run time. The compile time evaluation of
	a function does the equivalent of running the function at
	run time. This means that the semantics of a function cannot
	depend on compile time values of the function. For example:</p>

<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">char</span>[] s)
{
    <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(s);
}

<span class="d_keyword">const</span> <span class="d_keyword">int</span> x = foo(<span class="d_string">"1"</span>);
</pre>

	<p>is illegal, because the runtime code for foo() cannot be
	generated. A function template would be the appropriate
	method to implement this sort of thing.</p>

  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>




<div id="copyright">

Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Function
" title="Read/write comments and feedback">Comments</a>
</div>

</body>
</html>

